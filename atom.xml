<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Escawn</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://escawn.github.io/"/>
  <updated>2017-10-18T15:10:35.000Z</updated>
  <id>https://escawn.github.io/</id>
  
  <author>
    <name>escawn</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何不择手段提升scroll事件的性能</title>
    <link href="https://escawn.github.io/2017/10/18/%E5%A6%82%E4%BD%95%E4%B8%8D%E6%8B%A9%E6%89%8B%E6%AE%B5%E6%8F%90%E5%8D%87scroll%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%80%A7%E8%83%BD/"/>
    <id>https://escawn.github.io/2017/10/18/如何不择手段提升scroll事件的性能/</id>
    <published>2017-10-18T15:09:07.000Z</published>
    <updated>2017-10-18T15:10:35.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>&lt;!--假装此处有一个段子作为引子--&gt;</code></p>
<h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h2><ol>
<li><p>chrome devtool 是诊断页面滚动性能的有效工具</p>
</li>
<li><p>提升滚动时性能，就是要达到fps高且稳。</p>
</li>
<li><p>具体可以从以下方面着手</p>
<ul>
<li><p>使用web worker分离无页面渲染无关的逻辑计算</p>
</li>
<li><p>触发监听事件时使用函数节流与函数去抖</p>
</li>
<li><p>使用requestAnimationFrame与requestIdleCallback代替定时器</p>
</li>
<li><p>避免强制重排</p>
</li>
<li><p>提升合成层</p>
</li>
</ul>
</li>
</ol>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><!--此处应有scroll-performance使用场景-->
<p>滚动行为无时无刻不出现在我们浏览网页的行为中，在许多场景中，我们有有意识地、主动地去使用滚动操作，比如：</p>
<ul>
<li><p>懒加载</p>
</li>
<li><p>loadmore</p>
</li>
<li><p>affix</p>
</li>
<li><p>回到顶部</p>
</li>
</ul>
<p>以上场景伴随着滚动事件的监听操作，一不留神可能就让页面的滚动不再“如丝般顺滑”。</p>
<p><em>不择手段打造一个卡顿的scroll场景：</em><br><!--此处应p图上帝造人--></p>
<p><img src="http://7xw3pf.com1.z0.glb.clouddn.com/scroll-performance83634a4e9258d1093fb500e0d558ccbf6d814dc1.png" alt=""><img src="http://7xw3pf.com1.z0.glb.clouddn.com/scroll-performance0.png" alt=""></p>
<!--此处应有一个过渡-->
<p>作为一名优秀的前端工程师（未来的），怎么能容许出现这种情况！不就性能优化吗，撩起袖子就是干！</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><!--此处应有帧介绍-->
<p>在一个流畅的页面变化效果中（动画或滚动），<strong>渲染帧</strong>，指的是浏览器从js执行到paint的一次绘制过程，帧与帧之间快速地切换，由于人眼的残像错觉，就形成了动画的效果。那么这个“快速”，要达到多少才合适呢？</p>
<p>我们都知道，下层建筑决定了上层建筑。受限于目前大多数屏幕的刷新频率——<strong>60次/s</strong>，浏览器的渲染更新的页面的<strong>标准帧率</strong>也为<strong>60次/s</strong> – <strong>60FPS</strong>(frames/per second)。</p>
<ul>
<li>高于这个数字，在一次屏幕刷新的时间间隔<strong>16.7ms</strong>(1/60)内，就算浏览器渲染了多次页面，屏幕也只刷新一次，这就造成了性能的浪费。</li>
<li>低于这个数字，帧率下降，人眼就可能捕捉到两帧之间变化的滞涩与突兀，表现在屏幕上，就是页面的抖动，大家通常称之为<strong>卡顿</strong></li>
</ul>
<!--此处应有小火车的比喻示意图-->
<!--丢帧: 没赶上火车-->
<p>来个比喻。快递每天整理包裹，并一天一送。如果某天包裹太多，整理花费了太多时间，来不及当日（帧）送到收件人处，那就延期了（丢帧）。</p>
<!--此处应有浏览器渲染关键路径介绍-->
<p>那么在这16.7ms之内，浏览器都干了什么呢？</p>
<p>浏览器内心OS：不要老抱怨我延期（丢帧），我也很忙的好伐？</p>
<h3 id="帧维度解释帧渲染过程"><a href="#帧维度解释帧渲染过程" class="headerlink" title="帧维度解释帧渲染过程"></a>帧维度解释帧渲染过程</h3><p>浏览器渲染页面的<strong>Renderer</strong>进程里，涉及到了两个线程，二者之间通过名为Commit的消息保持同步：</p>
<ul>
<li><p>Main线程：浏览器渲染的主要执行步骤，包含从JS执行到Composite合成的一系列操作（下文会介绍）</p>
</li>
<li><p>Compositor线程：接收用户的一些交互操作(比如滚动) =&gt; 唤起Main线程进行操作 =&gt; 接收Main线程的操作结果 =&gt; commit给真正把页面draw到屏幕上的GPU进程</p>
</li>
</ul>
<p><strong>标准渲染帧：</strong></p>
<p><img src="https://img.alicdn.com/tps/TB19v8YLpXXXXXeXpXXXXXXXXXX-949-446.png" alt=""><br>在一个标准帧渲染时间16.7ms之内，浏览器需要完成Main线程的操作，并commit给Compositor进程</p>
<p><strong>丢帧：</strong><br><img src="https://img.alicdn.com/tps/TB1Tr4yLpXXXXbFaXXXXXXXXXXX-949-446.png" alt=""><br>主线程里操作太多，耗时长，commit的时间被推迟，浏览器来不及将页面draw到屏幕，这就丢失了一帧</p>
<p>那么Main线程里都有些什么操作会导致延时呢？</p>
<!--此处应有五个流程的截图 注明摘抄自官网-->
<h3 id="进一步解释浏览器主要执行步骤"><a href="#进一步解释浏览器主要执行步骤" class="headerlink" title="进一步解释浏览器主要执行步骤"></a>进一步解释浏览器主要执行步骤</h3><p><img src="https://developers.google.com/web/fundamentals/performance/rendering/images/intro/frame-full.jpg?hl=zh-cn" alt=""><br><!--此处应有五个流程的具体分析--></p>
<blockquote>
<ul>
<li><p>JavaScript：包含与视觉变化效果相关的<strong>js操作</strong>。包括并不限于：dom更新、元素样式动态改变、jQuery的animate函数等。</p>
</li>
<li><p>Style：样式计算。这个过程，浏览器根据css选择器计算哪些元素应该应用哪些规则，然后将样式规则落实到每个元素上去，确定每个元素具体的样式。</p>
</li>
<li><p>Layout：布局。在知道对一个元素应用哪些规则之后，浏览器即可开始计算它要占据的空间大小及其在屏幕的位置。</p>
</li>
<li><p>Painting：绘制。绘制是填充像素的过程。它涉及绘出文本、颜色、图像、边框和阴影，基本上包括元素的每个可视部分。绘制一般是在多个表面（通常称为层）上完成的。(paint和draw的区别：paint是把内容填充到页面，而draw是把页面反映到屏幕上)</p>
</li>
<li><p>Composite：合成。由于页面的各部分可能被绘制到多层，由此它们需要按正确顺序绘制到屏幕上，以便正确渲染页面。对于与另一元素重叠的元素来说，这点特别重要，因为一个错误可能使一个元素错误地出现在另一个元素的上层。</p>
</li>
</ul>
</blockquote>
<p>理论上，每次标准的渲染，浏览器Main线程需要执行JavaScript =&gt; Style =&gt; Layout =&gt; Paint =&gt; Composite五个步骤，但是实际上，要分场景。</p>
<table>
<thead>
<tr>
<th style="text-align:center">操作</th>
<th style="text-align:center">浏览器执行操作</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">dom改变/resize等改变窗口大小的事件</td>
<td style="text-align:center"><img src="https://developers.google.com/web/fundamentals/performance/rendering/images/intro/frame-full.jpg?hl=zh-cn" alt=""></td>
</tr>
<tr>
<td style="text-align:center">样式变动</td>
<td style="text-align:center"><img src="https://developers.google.com/web/fundamentals/performance/rendering/images/intro/frame-no-layout.jpg?hl=zh-cn" alt=""></td>
</tr>
<tr>
<td style="text-align:center">更改一个既不要布局也不要绘制的属性</td>
<td style="text-align:center"><img src="https://developers.google.com/web/fundamentals/performance/rendering/images/intro/frame-no-layout-paint.jpg?hl=zh-cn" alt=""></td>
</tr>
</tbody>
</table>
<p><strong>指路<a href="https://developers.google.com/web/fundamentals/performance/rendering/?hl=zh-cn" target="_blank" rel="external">官网</a></strong></p>
<h3 id="再进一步解释浏览器渲染流程"><a href="#再进一步解释浏览器渲染流程" class="headerlink" title="再进一步解释浏览器渲染流程"></a>再进一步解释浏览器渲染流程</h3><p><img src="http://7xw3pf.com1.z0.glb.clouddn.com/scroll-perforamceBrowser%20Render%20%281%29.png" alt=""></p>
<p>流程：</p>
<ol>
<li><p>Compositor线程接收一个vsync信号，表示这一帧开始</p>
</li>
<li><p>Compositor线程接收用户的交互输入（比如touchmove、scroll、click等）。然后commit给Main线程，这里有两点规则需要注意：</p>
<ul>
<li><p>并不是所有event都会commit给Main线程，部分操作比如单纯的滚动事件，打字等输入，不需要执行JS，也没有需要重绘的场景，Compositor线程就自己处理了，无需请求Main线程</p>
</li>
<li><p>同样的事件类型，不论一帧内被Compositor线程接收多少次，实际上commit给Main线程的，只会是一次，意味着也只会被执行一次。（HTML5标准里scroll事件是每帧触发一次）</p>
</li>
</ul>
</li>
<li><p>Main线程执行从JavaScript到Composite的过程，也有两点需要注意：</p>
<ul>
<li><p>注意红线，意思是可能会在JS里强制重排，当访问scrollWidth系列、clientHeight系列、offsetTop系列、ComputedStyle等属性时，会触发这个效果，导致Style和Layout前移到JS代码执行过程中。</p>
</li>
<li><p>实际上图中省略了Renderer进程中的其他线程，比如当Main线程走到js执行这一步时，会调起单独的js线程来执行。另外还有如HTML解释线程等。</p>
</li>
</ul>
</li>
<li><p>当Main线程完成最后合成之后，与Compositor线程使用commit进行通信，Compositor调起Compositor Tile Work(s)来辅助处理页面。Rasterize意为光栅化，想深入了解什么是光栅的小伙伴可以戳这里了解：<a href="https://chuckliu.me/#!/posts/58ea6af15dc1822fa9a57274" target="_blank" rel="external">浏览器渲染详细过程：重绘、重排和composite只是冰山一角</a></p>
</li>
<li><p>页面paint结束之后，这一帧就结束了。GPU进程里的GPU线程负责把Renderer进程操作好的页面，交由GPU，调用GPU内方法，由GPU把页面draw到屏幕上。</p>
</li>
<li><p>屏幕刷新，我们就在浏览器（屏幕）上看到了新页面。</p>
</li>
</ol>
<p>接下来，简要介绍一下，如何使用chrome devtool分析页面性能。</p>
<p>示意图（<em>chrome version: 61</em>）：<br><img src="http://7xw3pf.com1.z0.glb.clouddn.com/scroll-performancea00058647ba4f364bda782aabe862c89.png" alt=""></p>
<ul>
<li><p>帧率概览。看顶端绿色长条，越高代表帧率越高，高低起伏多代表帧率变化不稳定，越坑坑洼洼代表容易产生视觉上的卡顿。</p>
</li>
<li><p>分析具体某一帧。如果发现，有哪一帧帧率特别低，可以在中间那一栏找到耗时长的那一帧，点击进行具体的活动分析。</p>
</li>
<li><p>分析个活动耗时。自由选择某一段或某一帧观察这段时间内各项活动的耗时来诊断页面。(注意颜色)</p>
</li>
</ul>
<p>应该注意，我们可以看见，很少有帧的时间准确卡在了16.7s，实际上每帧达到60fps的帧率，只是一个理想化的数字，浏览器执行过程中可能受到各种情况的干扰。而我们人眼也没有那么灵敏，只要达到20帧以上，页面看起来就比较流畅了。尤其是结构复杂，数据较多的页面，盲目追求60fps只是钻牛角尖。所以，以我浅见，稳定的fps更能影响scroll效果。</p>
<p>关于<strong>更加具体地</strong>如何使用chome devtool分析页面性能，戳：<a href="https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/reference" target="_blank" rel="external">Performance Analysis Reference</a></p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>我们的目标很明确，就是拒绝卡顿！具体说来就是尽量赶在16.7ms之内让浏览器完成五项工作，压缩每个步骤时间。</p>
<h3 id="简化js内操作"><a href="#简化js内操作" class="headerlink" title="简化js内操作"></a>简化js内操作</h3><h4 id="使用web-worker"><a href="#使用web-worker" class="headerlink" title="使用web worker"></a>使用web worker</h4><p>当我们了解了浏览器渲染时执行的过程，并且清楚浏览器内核处理方式（处理js的线程与GUI页面渲染线程互斥）之后，我们很容易假想出这样一种状况：如果js大量的计算和逻辑操作霸占着浏览器，使页面渲染得不到处理，怎么办？</p>
<p>这种情况，很容易造成scroll的卡顿，甚至浏览器假死，就像<code>alert()</code>出现一样。</p>
<p>想象一下吧，本来大家好好地按照生理周期一个接一个上厕所，突然小j便秘了！你说排在他后面的小g急不急，可急死了！</p>
<p>web worker是什么？</p>
<blockquote>
<p>Web Worker为Web内容在后台线程中运行脚本提供了一种简单的方法。线程可以执行任务而不干扰用户界面。</p>
</blockquote>
<p>这就好像，给容易“便秘”的小j，单独搭了个简易厕所。</p>
<p>之所以说这是一个简易厕所，因为它有一些限制</p>
<ul>
<li><p>无法访问DOM节点</p>
</li>
<li><p>无法访问全局变量或是全局函数</p>
</li>
<li><p>无法调用alert()或者confirm之类的函数</p>
</li>
<li><p>无法访问window、document之类的浏览器全局变量</p>
</li>
</ul>
<blockquote>
<p>主线程和 worker 线程之间通过这样的方式互相传输信息：两端都使用 postMessage() 方法来发送信息, 并且通过 onmessage 这个 event handler来接收信息。 （传递的信息包含在 Message 这个事件的数据属性内) 。数据的交互是通过传递副本，而不是直接共享数据。</p>
</blockquote>
<p><strong>使用案例 - 判断素数</strong></p>
<p>案例来自<a href="https://dzone.com/articles/web-workers-responsive" target="_blank" rel="external">Web Workers, for a responsive JavaScript application</a></p>
<blockquote>
<p>素数，定义为在大于1的自然数中，除了1和它本身以外不再有其他因数。判断算法为，以2到它的平方根为界取整数做循环判断，用它和这个数字求余数，只要中间任意一次计算得到余数为零，则能够确认这个数字不是质数。</p>
</blockquote>
<p><strong>code</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">// in html</div><div class="line">&lt;script type="text/javascript"&gt;</div><div class="line">// we will use this function in-line in this page</div><div class="line">function isPrime(number)</div><div class="line">&#123;</div><div class="line">    if (number === 0 || number === 1) &#123;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">    var i;</div><div class="line">    for (i = 2; i &lt;= Math.sqrt(number); i++) &#123;</div><div class="line">        if (number % i === 0) &#123;</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return true;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// a large number, so that the computation time is sensible</div><div class="line">var number = "1000001111111111";</div><div class="line">// including the worker's code</div><div class="line">var w = new Worker('webworkers.js');</div><div class="line">// the callback for the worker to call</div><div class="line">w.onmessage = function(e) &#123;</div><div class="line">    if (e.data) &#123;</div><div class="line">        alert(number + ' is prime. Now I\'ll try calculating without a web worker.');</div><div class="line">        var result = isPrime(number);</div><div class="line">        if (result) &#123;</div><div class="line">            alert('I am sure, it is prime. ');</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        alert(number + ' is not prime.');</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">// sending a message to the worker in order to start it</div><div class="line">w.postMessage(number);</div><div class="line"></div><div class="line">&lt;/script&gt;</div><div class="line">&lt;p style="height: 200px; width: 400px; overflow: scroll;"&gt;</div><div class="line">Lorem ipsum dolor sit amet, consectetur adipiscing elit. Fusce blandit tristique risus, a rhoncus nisl posuere sed. Praesent vel risus turpis, et fermentum lectus. Ut lacinia nunc dui. Sed a velit orci. Maecenas quis diam neque. Vestibulum id arcu purus, quis cursus arcu. Etiam luctus, risus eu scelerisque scelerisque, sapien felis tincidunt ante, vel pellentesque eros nunc at magna. Nam tincidunt mattis velit ut condimentum. Vivamus ipsum ipsum, venenatis vitae placerat eu, convallis quis metus. Quisque tortor sapien, dapibus non vehicula quis, dapibus at purus. Nunc posuere, ligula sed facilisis sagittis, justo massa placerat nulla, nec pellentesque libero erat ut ligula. Aenean molestie, urna quis molestie auctor, lorem purus hendrerit nisi, vitae tincidunt metus massa et dolor. Sed leo velit, iaculis tristique elementum tincidunt, ornare et tellus. Quisque lacinia felis at est faucibus in facilisis dui consectetur. Phasellus sed ante id tortor pretium ornare. Aliquam ante justo, aliquam ut mollis semper, mattis sit amet urna. Pellentesque placerat, diam nec consectetur blandit, libero metus placerat massa, quis mattis metus metus nec lorem.</div><div class="line">&lt;/p&gt;</div><div class="line"></div><div class="line"></div><div class="line">// in webworkers.js</div><div class="line">function isPrime(number)</div><div class="line">&#123;</div><div class="line">    if (number === 0 || number === 1) &#123;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">    var i;</div><div class="line">    for (i = 2; i &lt;= Math.sqrt(number); i++) &#123;</div><div class="line">        if (number % i === 0) &#123;</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return true;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// this is the point of entry for the workers</div><div class="line">onmessage = function(e) &#123;</div><div class="line">    // you can support different messages by checking the e.data value</div><div class="line">    number = e.data;</div><div class="line">    result = isPrime(number);</div><div class="line">    // calling back the main thread</div><div class="line">    postMessage(result);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>代码说明：</p>
<ul>
<li><p>使用web worker对一个较大数字（1000001111111111）进行素数判断</p>
</li>
<li><p>得到结果之后<code>alert(number + &#39; is prime. Now I\&#39;ll try calculating without a web worker.&#39;)</code></p>
</li>
<li><p>在不使用web worker的情况下，对相同数字进行素数判断，完成后<code>alert(&#39;I am sure, it is prime. &#39;)</code></p>
</li>
<li><p>从页面</p><p>标签里的内容的滚动情况判断两次计算对浏览器/页面造成的影响</p>
</li>
</ul>
<p>现场还原：<br><img src="http://7xw3pf.com1.z0.glb.clouddn.com/scroll-performance2017-10-09_15-56-48.gif" alt=""><br><a href="http://7xw3pf.com1.z0.glb.clouddn.com/scroll-performance2017-10-09_15-56-48.gif" target="_blank" rel="external">不动戳我</a></p>
<p><strong>案例总结</strong>：<br>从两次alert之后的段落滚动情况（第二次根本动不了），足以看出大量繁杂的js计算对页面的影响。恰当地使用web worker，<strong>能有效缓解页面scroll阻塞的情况</strong>。</p>
<p>而且它的支持率也良好~<br><img src="http://7xw3pf.com1.z0.glb.clouddn.com/scroll-performance%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-09%20%E4%B8%8B%E5%8D%883.31.42.png" alt=""></p>
<p>在应用方面，Angular已经做了一些尝试。</p>
<p><a href="https://zhuanlan.zhihu.com/p/28365967" target="_blank" rel="external">解密Angular WebWorker Renderer (一)</a>：想办法打破web worker本身不能操作dom元素等限制，利用web worker执行渲染操作</p>
<p><strong><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Using_web_workers" target="_blank" rel="external">Learn more about web worker</a></strong></p>
<h4 id="函数节流与函数去抖"><a href="#函数节流与函数去抖" class="headerlink" title="函数节流与函数去抖"></a>函数节流与函数去抖</h4><!--此处应有函数节流与函数去抖介绍-->
<p>针对scroll事件中的回调，思路之一是对事件进行“稀释”，减少事件回调的执行次数。</p>
<p>这就涉及到两个概念：函数节流和函数去抖</p>
<ul>
<li><p>函数节流（throttle）：让函数在指定的时间段内<strong>周期性地间断</strong>执行</p>
</li>
<li><p>函数去抖（debounce）：让函数只有在过完一段时间后并且<strong>该段时间内不被调用</strong>才会被执行</p>
</li>
</ul>
<p>有人这样比喻：</p>
<blockquote>
<p>就像一窝蜂的人去排队看演出，队伍很乱，看门的老大爷每隔1秒，让进一个人，这个叫throttle，如果来了这一窝蜂的人，老大爷一次演出只让进一个人，下次演出才让下一个人进，这个就叫debounce</p>
</blockquote>
<p>OK, text is long, show you code.</p>
<p>以下code来自<a href="https://github.com/jashkenas/underscore/blob/master/underscore.js" target="_blank" rel="external">underscore.js</a>(类似jQuery的库，封装了一些方法)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Returns a function, that, when invoked, will only be triggered at most once</span></div><div class="line">  <span class="comment">// during a given window of time. Normally, the throttled function will run</span></div><div class="line">  <span class="comment">// as much as it can, without ever going more than once per `wait` duration;</span></div><div class="line">  <span class="comment">// but if you'd like to disable the execution on the leading edge, pass</span></div><div class="line">  <span class="comment">// `&#123;leading: false&#125;`. To disable execution on the trailing edge, ditto.</span></div><div class="line">  _.throttle = <span class="function"><span class="keyword">function</span>(<span class="params">func, wait, options</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> timeout, context, args, result;</div><div class="line">    <span class="comment">// 标记时间戳</span></div><div class="line">    <span class="keyword">var</span> previous = <span class="number">0</span>;</div><div class="line">    <span class="comment">// options可选属性 leading: true/false 表示第一次事件马上触发回调/等待wait时间后触发</span></div><div class="line">    <span class="comment">// options可选属性 trailing: true/false 表示最后一次回调触发/最后一次回调不触发</span></div><div class="line">    <span class="keyword">if</span> (!options) options = &#123;&#125;;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> later = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      previous = options.leading === <span class="literal">false</span> ? <span class="number">0</span> : _.now();</div><div class="line">      timeout = <span class="literal">null</span>;</div><div class="line">      result = func.apply(context, args);</div><div class="line">      <span class="keyword">if</span> (!timeout) context = args = <span class="literal">null</span>;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> throttled = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="comment">// 记录当前时间戳</span></div><div class="line">      <span class="keyword">var</span> now = _.now();</div><div class="line">      <span class="comment">// 如果是第一次触发且选项设置不立即执行回调</span></div><div class="line">      <span class="keyword">if</span> (!previous &amp;&amp; options.leading === <span class="literal">false</span>)</div><div class="line">      <span class="comment">// 将记录的上次执行的时间戳置为当前</span></div><div class="line">      previous = now;</div><div class="line">      <span class="comment">// 距离下次触发回调还需等待的时间</span></div><div class="line">      <span class="keyword">var</span> remaining = wait - (now - previous);</div><div class="line">      context = <span class="keyword">this</span>;</div><div class="line">      args = <span class="built_in">arguments</span>;</div><div class="line"></div><div class="line">      <span class="comment">// 等待时间 &lt;= 0或者不科学地 &gt; wait（异常情况）</span></div><div class="line">      <span class="keyword">if</span> (remaining &lt;= <span class="number">0</span> || remaining &gt; wait) &#123;</div><div class="line">        <span class="keyword">if</span> (timeout) &#123;</div><div class="line">        	<span class="comment">// 清除定时器</span></div><div class="line">          clearTimeout(timeout);</div><div class="line">          <span class="comment">// 解除引用</span></div><div class="line">          timeout = <span class="literal">null</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 将记录的上次执行的时间戳置为当前</span></div><div class="line">        previous = now;</div><div class="line"></div><div class="line">        <span class="comment">// 触发回调</span></div><div class="line">        result = func.apply(context, args);</div><div class="line">        <span class="keyword">if</span> (!timeout) context = args = <span class="literal">null</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="comment">// 在定时器不存在且选项设置最后一次触发需要执行回调的情况下</span></div><div class="line">      <span class="comment">// 设置定时器，间隔remaining时间后执行later</span></div><div class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (!timeout &amp;&amp; options.trailing !== <span class="literal">false</span>) 	  &#123;</div><div class="line">        timeout = setTimeout(later, remaining);</div><div class="line">      &#125;</div><div class="line">     <span class="keyword">return</span> result;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    throttled.cancel = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      clearTimeout(timeout);</div><div class="line">      previous = <span class="number">0</span>;</div><div class="line">      timeout = context = args = <span class="literal">null</span>;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> throttled;</div><div class="line">  &#125;;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">// Returns a function, that, as long as it continues to be invoked, will not</div><div class="line">// be triggered. The function will be called after it stops being called for</div><div class="line">// N milliseconds. If `immediate` is passed, trigger the function on the</div><div class="line">// leading edge, instead of the trailing.</div><div class="line">_.debounce = function(func, wait, immediate) &#123;</div><div class="line">  var timeout, result;</div><div class="line"></div><div class="line">// 定时器设置的回调，清除定时器，执行回调函数func</div><div class="line">  var later = function(context, args) &#123;</div><div class="line">    timeout = null;</div><div class="line">    if (args) result = func.apply(context, args);</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">// restArgs函数将传入的func的参数改造成Rest Parameters —— 一个参数数组</div><div class="line">  var debounced = restArgs(function(args) &#123;</div><div class="line">    if (timeout) clearTimeout(timeout);</div><div class="line">    if (immediate) &#123;</div><div class="line">      // 立即触发的条件：immediate为true且timeout为空</div><div class="line">      var callNow = !timeout;</div><div class="line">      timeout = setTimeout(later, wait);</div><div class="line">      if (callNow) result = func.apply(this, args);</div><div class="line">    &#125; else &#123;</div><div class="line">      // _.delay方法实际上是setTimeout()包裹了一层参数处理的逻辑</div><div class="line">      timeout = _.delay(later, wait, this, args);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return result;</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  debounced.cancel = function() &#123;</div><div class="line">    clearTimeout(timeout);</div><div class="line">    timeout = null;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  return debounced;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>对比以上代码，我们可以发现，两种方法应用的场景时有差别的</p>
<ul>
<li><p>函数节流：适用于多次提交（commit）的场景，如点击按钮提交发送请求的情况</p>
</li>
<li><p>函数去抖：适用于scroll/resize等场景</p>
</li>
</ul>
<p>相对于多次触发只执行一次的debounce，间隔地执行回调的throttle更能满足“稀释”scroll事件的需求。</p>
<p>至于wait的设定值，到底多久执行一次比较合适？很大部分还是取决于具体的场景&amp;代码复杂度，但是这里有一个例子可以参考：<a href="https://johnresig.com/blog/learning-from-twitter/" target="_blank" rel="external">Learning from Twitter</a></p>
<p>2011年Twitter出现过滚动性能差到严重影响用户体验的案例，原因是</p>
<blockquote>
<ul>
<li><p>It’s a very, very, bad idea to attach handlers to the window scroll event.</p>
</li>
<li><p>Always cache the selector queries that you’re re-using.</p>
</li>
</ul>
</blockquote>
<p>最后采用了函数节流的办法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var outerPane = $details.find(&quot;.details-pane-outer&quot;),</div><div class="line">    didScroll = false;</div><div class="line"></div><div class="line">$(window).scroll(function() &#123;</div><div class="line">    didScroll = true;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">setInterval(function() &#123;</div><div class="line">    if ( didScroll ) &#123;</div><div class="line">        didScroll = false;</div><div class="line">        // Check your page position and then</div><div class="line">        // Load in more results</div><div class="line">    &#125;</div><div class="line">&#125;, 250);</div></pre></td></tr></table></figure>
<p>示例中给出的数字250，可以给大家参考一下~</p>
<h3 id="去定时器"><a href="#去定时器" class="headerlink" title="去定时器"></a>去定时器</h3><p>为什么定时器会引起掉帧？<br><img src="http://upload-images.jianshu.io/upload_images/1158202-e144d3fcbe900a0c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>如你所见，定时器导致掉帧的原因，就在于无法准确控制回调执行的时机。</p>
<p>即使给定时器设置延时时间wait恰好为16.7ms，也不行。</p>
<p>js的单线程限制了回调会在16.7ms之后加入任务队列，却不能保证一定在16.7ms之后触发。如果当下js正在进行耗时计算，回调就只能等着。所以实际上回调执行的时机，是定时器设置后 &gt;= 16.7ms后。</p>
<p>那么去定时器是否意味着否定了之前说的函数去抖和函数节流操作？</p>
<p>NONONO，这两种提升scroll性能的操作应用于不同的场景：</p>
<ul>
<li><p>scroll过程中伴随着不直接改变画面效果的计算操作，如懒加载、loadmore等，在这样的scroll场景里，我们要不断进行判断操作，大量的计算操作就可能阻塞scroll，所以要对操作进行“稀释”。</p>
</li>
<li><p>scroll过程中伴随着直接改变画面效果的操作，如动画、affix引起的scroll滚动等。</p>
</li>
</ul>
<p><strong>案例：</strong><br>在这个世界上，有一种经典的导航栏形式，那就是，affix。</p>
<blockquote>
<p>这种导航栏在你scroll时会粘在你的窗口的固定位置（一般是top），并且在你点击导航栏时自动滚动到页面对应的target内容。</p>
</blockquote>
<p><img src="http://7xw3pf.com1.z0.glb.clouddn.com/scroll-performance2017-10-10_13-16-28.gif" alt=""></p>
<p><a href="http://7xw3pf.com1.z0.glb.clouddn.com/scroll-performance2017-10-10_13-16-28.gif" target="_blank" rel="external">不动戳我</a></p>
<p>这是我自己做的一个小demo，利用了setInterval，每16.7ms设置scrollTop + 5px，达到“平滑”滚动的效果。</p>
<p><img src="http://7xw3pf.com1.z0.glb.clouddn.com/scroll-performance%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-10%20%E4%B8%8A%E5%8D%8811.27.27.png" alt=""><br>emmmm，看着不规则的锯齿，难受。</p>
<p>如果还不够明显，试试将wait设为50ms</p>
<p><img src="http://7xw3pf.com1.z0.glb.clouddn.com/scroll-performance%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-10%20%E4%B8%8A%E5%8D%8811.29.50.png" alt=""></p>
<p>看起来，要赶上每一个标准帧渲染的时机，不是那么容易，但是旁友，你听说过安利吗？哦走错片场了，是<code>requestAnimationFrame()</code>和<code>requestIdleCallback()</code>.</p>
<p><strong>requestAnimationFrame()</strong></p>
<blockquote>
<p>The window.requestAnimationFrame() method tells the browser that you wish to perform an animation and requests that the browser call a specified function to update an animation before the next repaint. The method takes a callback as an argument to be invoked before the repaint.</p>
</blockquote>
<p>可以将它看做一个钩子，刚好卡在浏览器重绘前向我们的操作伸出橄榄枝。实际上它更像定时器，每秒60次执行回调——符合屏幕的刷新频率，遇到耗时长的操作，这个数字会降到30来保证稳定的帧数。</p>
<p>语法也很简单：<code>window.requestAnimationFrame(callback)</code></p>
<p>更改后的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">const newScrollTop = this.getPosition(this.panes[index].$refs.content).top - this.distance</div><div class="line"></div><div class="line">function scrollStep() &#123;</div><div class="line">	document.documentElement.scrollTop += 5</div><div class="line">	if (document.documentElement.scrollTop &lt; newScrollTop) &#123;</div><div class="line">		window.requestAnimationFrame(scrollStep)</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">window.requestAnimationFrame(scrollStep)</div></pre></td></tr></table></figure>
<p>与定时器很相似，只是鉴于其一次执行只调用一次回调，所以需要以递归的方式书写。</p>
<p>测试一下：<br><img src="http://7xw3pf.com1.z0.glb.clouddn.com/scroll-performance%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-10%20%E4%B8%8A%E5%8D%8811.55.52.png" alt=""></p>
<p>可以说是很顺滑了~</p>
<p>兼容性呢？</p>
<p><img src="http://7xw3pf.com1.z0.glb.clouddn.com/scroll-performance%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-10%20%E4%B8%8A%E5%8D%8811.43.22.png" alt=""></p>
<p>不错不错~</p>
<p><strong><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame" target="_blank" rel="external">Learn more about requestAnimationFrame()</a></strong></p>
<p><strong>requestIdleCallback()</strong></p>
<blockquote>
<p>The window.requestIdleCallback() method queues a function to be called during a browser’s idle periods. This enables developers to perform background and low priority work on the main event loop, without impacting latency-critical events such as animation and input response. Functions are generally called in first-in-first-out order; however, callbacks which have a timeout specified may be called out-of-order if necessary in order to run them before the timeout elapses.</p>
</blockquote>
<p>意思是，它会在一帧末尾浏览器空闲时触发回调，否则，推迟到下一帧。</p>
<p>看定义，它适合应用于执行在后台运行或者优先度低的任务，但是鉴于我们的案例逻辑和计算都比较简单，应该能满足<strong>一帧末尾有空闲</strong>（毕竟标题是“不择手段”），have a try.</p>
<p>实际上，基础使用上<code>requestIdleCallback()</code>和<code>requestAnimationFrame()</code>语法相同，代码修改甚至也只替换了方法名。</p>
<p>应用情况呢？</p>
<p><img src="http://7xw3pf.com1.z0.glb.clouddn.com/scroll-performance%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-10%20%E4%B8%8A%E5%8D%8811.58.33.png" alt=""></p>
<p>也是如丝般顺滑~仔细看每一帧，我们会发现，Fire Idle Callback正如其定义，出现在每帧的最后。</p>
<p>但是兼容性看起来除了chrome和FireFox之外，就不是那么友好了：<br><img src="http://7xw3pf.com1.z0.glb.clouddn.com/scroll-performance%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-10%20%E4%B8%8A%E5%8D%8811.59.16.png" alt=""></p>
<p><strong>总结：</strong>在追求高性能的渲染效果时，可以考虑用<code>requestIdleCallback()</code>和<code>requestAnimationFrame()</code>代替定时器。前者适合流畅的动画效果场景，后者适用于分离一些优先级低的操作逻辑，使用时需要考虑清楚。</p>
<h3 id="避免强制重排"><a href="#避免强制重排" class="headerlink" title="避免强制重排"></a>避免强制重排</h3><p>记忆力好的同学可能还记得，我们在之前描述浏览器渲染过程时，提到一个强制重排的概念，它的特点是，会插队！</p>
<blockquote>
<p>注意红线，意思是可能会在JS里强制重排，当访问scrollWidth系列、clientHeight系列、offsetTop系列、ComputedStyle等属性时，会触发这个效果，导致Style和Layout前移到JS代码执行过程中</p>
</blockquote>
<p>这个强制重排(force layout)听起来好像和重排很像啊，那么它和重排以及重绘是什么关系呢？</p>
<p>优秀的前端工程师对重绘和重绘的概念已经很熟悉了，我这里就不再赘述。浏览器有自己的优化机制，包括之前提到的每帧只响应同类别的事件一次，再比如这里的会把一帧里的多次重排、重绘汇总成一次进行处理。</p>
<p><strong>flush队列</strong>是浏览器进行重排、重绘等操作的队列，所有会引起重排重绘的操作都包含在内，比如dom修改、样式修改等。如果每次js操作都去执行一次重排重绘，那么浏览器一定会卡卡卡卡卡，所以浏览器通常是<strong>在一定的时间间隔（一帧）内，批量处理队列里的操作</strong>。但是，对于有些操作，比如获取元素相对父级元素左边界的偏移值（Element.offsetLeft），但在此之前我们进行了样式或者dom修改，这个操作还攒在flush队列里没有执行，那么浏览器为了让我们获取正确的offsetLeft（虽然之前的操作可能不会影响offsetLeft的值），就会立即执行队列里的操作。<br><img src="http://7xw3pf.com1.z0.glb.clouddn.com/flush111.png" alt=""></p>
<p>所以我们知道了，就是这个特殊操作会影响浏览器正常的执行和渲染，假设我们频繁执行这样的特殊操作，就会打断浏览器原来的节奏，增大开销。</p>
<p>而这个特殊操作，具体指的就是：</p>
<ul>
<li><code>elem.offsetLeft</code>, <code>elem.offsetTop</code>, <code>elem.offsetWidth</code>, <code>elem.offsetHeight</code>, <code>elem.offsetParent</code></li>
<li><code>elem.clientLeft</code>, <code>elem.clientTop</code>, <code>elem.clientWidth</code>, <code>elem.clientHeight</code></li>
<li><code>elem.getClientRects()</code>, <code>elem.getBoundingClientRect()</code></li>
<li><code>elem.scrollWidth</code>, <code>elem.scrollHeight</code></li>
<li><code>elem.scrollLeft</code>, <code>elem.scrollTop</code></li>
<li>…</li>
</ul>
<p><strong><a href="https://gist.github.com/paulirish/5d52fb081b3570c81e3a" target="_blank" rel="external">See more：What forces layout / reflow</a></strong></p>
<p>解决办法呢，有俩：</p>
<ul>
<li><p>基础版：使用前面提到过的<code>requestAnimationFrame()</code>，将以上特殊操作汇集并延迟入队</p>
</li>
<li><p>进阶版：使用第三方<a href="https://github.com/wilsonpage/fastdom" target="_blank" rel="external">FastDom</a>帮助我们自动完成读写操作的批处理,实际上它也是建立在<code>requestAnimationFrame()</code>上构造的。<a href="http://wilsonpage.github.io/fastdom/examples/animation.html" target="_blank" rel="external">官方提供的example</a>看起来效果简直优秀</p>
<blockquote>
<p>FastDom works as a regulatory layer between your app/library and the DOM. By batching DOM access we avoid unnecessary document reflows and dramatically speed up layout performance.<br>  Each measure/mutate job is added to a corresponding measure/mutate queue. The queues are emptied (reads, then writes) at the turn of the next frame using window.requestAnimationFrame.<br>  FastDom aims to behave like a singleton across all modules in your app. When any module requires ‘fastdom’ they get the same instance back, meaning FastDom can harmonize DOM access app-wide.<br>  Potentially a third-party library could depend on FastDom, and better integrate within an app that itself uses it.</p>
</blockquote>
</li>
</ul>
<p><strong>总结：</strong>谨慎使用以上特殊的读操作，要使用也尽量汇集、包裹（<code>requestAnimationFrame()</code>），避免单个裸奔。</p>
<p><strong><a href="https://developers.google.com/web/tools/chrome-devtools/rendering-tools/forced-synchronous-layouts?hl=zh-cn" target="_blank" rel="external">Learn more about how to giagnose forced synchronous layouts with chrome DevTools</a></strong></p>
<h3 id="提升合成层"><a href="#提升合成层" class="headerlink" title="提升合成层"></a>提升合成层</h3><p>不知道有没有人，曾经围坐在黑夜里的炉火旁边，听前端前辈们传递智慧的话语 —— 做位移效果时使用tranform代替top/left/bottom/right，尤其是移动端！</p>
<p>why？</p>
<p>因为top/left/bottom/right属性性能差呀 —— 这类属性会影响元素在文档中的布局，可能改变其他元素的位置，引起重排，造成性能开销</p>
<p>因为tranform属性性能好呀 —— 使用transform属性（3D/animation）将元素提升至合成层，省去布局和绘制环节，美滋滋~</p>
<p>说到这里，你可能还不是太清楚合成层的概念，其实看这篇就够了：<a href="http://taobaofed.org/blog/2016/04/25/performance-composite/" target="_blank" rel="external">无线性能优化：Composite</a></p>
<p>但是照顾一下有些“太长不看”猫病的旁友们，在这里做一些总结。</p>
<ol>
<li><p>一些属性会让元素们<strong>创建出不同的渲染层</strong></p>
<ul>
<li>有明确的定位属性（relative、fixed、sticky、absolute）</li>
<li>透明的（opacity 小于 1）</li>
<li>有 CSS 滤镜（fliter）</li>
<li>有 CSS transform 属性（不为 none）</li>
<li>…</li>
</ul>
</li>
<li><p>达成一些条件，<strong>渲染层会提升为合成层</strong></p>
<ul>
<li>硬件加速的 iframe 元素（比如 iframe 嵌入的页面中有合成层）</li>
<li>3D 或者 硬件加速的 2D Canvas 元素</li>
<li>video 元素</li>
<li>有 3D transform</li>
<li>对 opacity、transform、fliter、backdropfilter 应用了 animation 或者 transition</li>
<li>will-change 设置为 opacity、transform、top、left、bottom、right（其中 top、left 等需要设置明确的定位属性，如 relative 等）</li>
<li>…</li>
</ul>
</li>
</ol>
<p>提升为合成层干什么呢？普通的渲染层普通地渲染，用普通的顺序普通地合成不好吗？非要搞啥特殊待遇！</p>
<p>浏览器就说了：我这也是为了大家共同进步（提升速度）！看那些搞特殊待遇的，都是一些拖我们队伍后腿的(性能开销大)，分开处理，才能保证整个队伍稳定快速的进步！</p>
<p><strong>特殊待遇</strong>：合成层的位图，会交由 GPU 合成，比 CPU 处理要快。当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层。</p>
<blockquote>
<p>对布局属性进行动画，浏览器需要为每一帧进行重绘并上传到 GPU 中</p>
<p>对合成属性进行动画，浏览器会为元素创建一个独立的复合层，当元素内容没有发生改变，该层就不会被重绘，浏览器会通过重新复合来创建动画帧</p>
</blockquote>
<p>所以，从合成层出发，为了优化scroll性能，我们可以做这些：</p>
<p><strong><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/will-change" target="_blank" rel="external">will-change</a></strong></p>
<p>提升合成层的有效方式，应用这个属性，实际上是提前通知浏览器，为接下来的动画效果操作做准备。值得注意的是</p>
<ul>
<li><p>不要将 will-change 应用到太多元素上，增加渲染层意味着新的内存分配和更复杂的层的管理</p>
</li>
<li><p>有节制地使用。动态样式增加比一开始就写在样式表里更能减少不必要的开销。</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">will-change: scroll-position // 表示开发者希望在不久后改变滚动条的位置或者使之产生动画。</div></pre></td></tr></table></figure>
<p>然后，国际惯例【并不，附上兼容性</p>
<p><img src="http://7xw3pf.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-11%20%E4%B8%8B%E5%8D%883.59.18.png" alt=""></p>
<p><strong>除此之外</strong></p>
<ul>
<li><p>使用 transform 或者 opacity 来实现动画效果</p>
</li>
<li><p>对于较少可能变化的区域，防止页面其他部分重绘时影响这一片，考虑提升至合成层。</p>
</li>
<li><p>提升合成层的hack方法：<code>translateZ(0)</code></p>
</li>
</ul>
<p><strong>总结：</strong>从合成层的角度作为性能提升的下手方向，是值得肯定的，但是具体采用什么样的方案，还是要先切实地分析页面的实际性能表现，根据不同的场景，综合考虑方案的得失，再总结出正确的优化途径。</p>
<h3 id="what’s-more"><a href="#what’s-more" class="headerlink" title="what’s more"></a>what’s more</h3><h4 id="使用css属性代替js“模拟操作”"><a href="#使用css属性代替js“模拟操作”" class="headerlink" title="使用css属性代替js“模拟操作”"></a>使用css属性代替js“模拟操作”</h4><p><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/scroll-behavior" target="_blank" rel="external">scroll-behavior</a></p>
<blockquote>
<p>The scroll-behavior CSS property specifies the scrolling behavior for a scrolling box, when scrolling happens due to navigation or CSSOM scrolling APIs. Any other scrolls, e.g. those that are performed by the user, are not affected by this property. When this property is specified on the root element, it applies to the viewport instead.</p>
</blockquote>
<p>可以借此实现affix，而不用使用定时器或<code>requestAnimationFrame</code>模拟平滑的scroll操作</p>
<p>demo戳：<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/scroll-behavior" target="_blank" rel="external">锚点链接+scroll-behavior</a></p>
<p><img src="http://7xw3pf.com1.z0.glb.clouddn.com/scroll-performance2017-10-11_19-36-59.gif" alt=""></p>
<p>但是目前仅是实验性的功能，残念<br><img src="http://7xw3pf.com1.z0.glb.clouddn.com/scroll-performance%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-11%20%E4%B8%8B%E5%8D%887.40.28.png" alt=""></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>页面渲染性能的优化涉及方方面面，这里只是以scroll事件为立足点分析列举了一些改善的方法，深入性和全面性都不足，但更多希望能起到一个引子的作用，给有心深入的同学一个概括性的印象。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>以下这些大大们的文章都很值得阅读分析做笔记！</p>
<ul>
<li><p><a href="https://developers.google.com/web/fundamentals/performance/rendering/?hl=zh-cn" target="_blank" rel="external">渲染性能</a></p>
</li>
<li><p><a href="https://github.com/chokcoco/cnblogsArticle/issues/12" target="_blank" rel="external">【前端性能】高性能滚动 scroll 及页面渲染优化</a></p>
</li>
<li><p><a href="https://chuckliu.me/#!/posts/58ea6af15dc1822fa9a57274" target="_blank" rel="external">浏览器渲染详细过程：重绘、重排和 composite 只是冰山一角</a></p>
</li>
<li><p><a href="https://dzone.com/articles/web-workers-responsive" target="_blank" rel="external">Web Workers, for a responsive JavaScript application</a></p>
</li>
<li><p><a href="https://github.com/hanzichi/underscore-analysis/issues/20" target="_blank" rel="external">JavaScript 函数节流和函数去抖应用场景辨析</a></p>
</li>
<li><p><a href="https://github.com/aooy/blog/issues/5" target="_blank" rel="external">从event loop规范探究javaScript异步及浏览器更新渲染时机</a></p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;&amp;lt;!--假装此处有一个段子作为引子--&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;TL-DR&quot;&gt;&lt;a href=&quot;#TL-DR&quot; class=&quot;headerlink&quot; title=&quot;TL;DR&quot;&gt;&lt;/a&gt;TL;DR&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;ch
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【踩坑】Vue-eventBus异常触发事件情形</title>
    <link href="https://escawn.github.io/2017/08/09/vue%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86eventBus%E4%B9%8B%E5%9D%91/"/>
    <id>https://escawn.github.io/2017/08/09/vue事件处理eventBus之坑/</id>
    <published>2017-08-09T11:04:23.000Z</published>
    <updated>2017-08-15T08:38:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>eventBus是一个vue实例，上面挂载了许多监听事件，通过触发相应的监听事件，可以实现不同层级的组件之间的通信。<br><a id="more"></a></p>
<h3 id="eventBus简介"><a href="#eventBus简介" class="headerlink" title="eventBus简介"></a>eventBus简介</h3><p>eventBus是为小型项目等组件层级不深，状态不复杂的项目提供的组件通信方案，它本质上可以看做是一个挂载了许多事件的vue实例，在所需组件中引入这个实例，以此为桥梁，触发不同层级组件中监听的事件。</p>
<h4 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h4><h5 id="单独的eventBus文件"><a href="#单独的eventBus文件" class="headerlink" title="单独的eventBus文件"></a>单独的eventBus文件</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 单独声明一个eventBus.js，里面仅需声明一个vue实例</span></div><div class="line"><span class="comment">// eventBus.js</span></div><div class="line"><span class="keyword">import</span> vue <span class="keyword">from</span> <span class="string">"vue"</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> eventBus = <span class="keyword">new</span> Vue(&#123;&#125;)</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> eventBus</div><div class="line"></div><div class="line"><span class="comment">// componentA</span></div><div class="line"><span class="keyword">import</span> eventBus <span class="keyword">from</span> <span class="string">'./eventBus.js'</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">	<span class="comment">// 此处省略n行代码</span></div><div class="line">	methods: &#123;</div><div class="line">		func(params) &#123;</div><div class="line">			<span class="built_in">console</span>.log(<span class="string">'组件A的被触发了，'</span> + <span class="string">'参数为：'</span> + params)</div><div class="line">		&#125;</div><div class="line">	&#125;,</div><div class="line">	<span class="attr">mounted</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="keyword">this</span>.$nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">			eventBus.$on(<span class="string">'message'</span>, (params) =&gt; <span class="keyword">this</span>.func(params))</div><div class="line">		&#125;)</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// componentB</span></div><div class="line"><span class="keyword">import</span> eventBus <span class="keyword">from</span> <span class="string">'./eventBus.js'</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">	<span class="comment">// 在组件B mounted时触发事件A中事件</span></div><div class="line">	mounted: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="keyword">this</span>.$nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">			eventBus.$emit(<span class="string">'message'</span>, (<span class="string">'hhhhhh'</span>))</div><div class="line">		&#125;)</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 组件A的message被触发了，参数为：hhhhh</span></div></pre></td></tr></table></figure>
<h5 id="组件中声明"><a href="#组件中声明" class="headerlink" title="组件中声明"></a>组件中声明</h5><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">// componentA</div><div class="line">&lt;script&gt;</div><div class="line">import Vue from 'vue'</div><div class="line">export default &#123;</div><div class="line">	data() &#123;</div><div class="line">		return &#123;</div><div class="line">			eventBus: new Vue(&#123;&#125;)</div><div class="line">		&#125;</div><div class="line">	&#125;,</div><div class="line">	methods: &#123;</div><div class="line">		func(params) &#123;</div><div class="line">			console.log('组件A的被触发了，' + '参数为：' + params)</div><div class="line">		&#125;</div><div class="line">	&#125;,</div><div class="line">	mounted: function()&#123;</div><div class="line">		this.nextTick(function()&#123;</div><div class="line">			this.eventBus.$on('message', (params) =&gt; this.func(params))</div><div class="line">		&#125;)</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;template&gt;</div><div class="line">&lt;!-- 此处省略n行代码 --&gt;</div><div class="line">&lt;component-b :event-bus="eventBus"&gt;&lt;/component-b&gt;</div><div class="line">&lt;/template&gt;</div><div class="line"></div><div class="line">// componentB</div><div class="line">export default &#123;</div><div class="line">	props: &#123;</div><div class="line">		eventBus: &#123;</div><div class="line">			type: Object</div><div class="line">		&#125;</div><div class="line">	&#125;,</div><div class="line">	// 在组件B mounted时触发事件A中事件</div><div class="line">	mounted: function()&#123;</div><div class="line">		this.$nextTick(function()&#123;</div><div class="line">			this.eventBus.$emit('message', ('hhhhhh'))</div><div class="line">		&#125;)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，在组件中创建eventBus的方式适用于有直接嵌套关系，并且层级不深的组件，比如父子组件（但是明显父子组件之间有更加便捷的通信方式）。一旦涉及层级较深，事件较多的情形（但是又没复杂到需要使用vuex的地步），我们会采用单文件eventBus直接引入的方式。这样的方式会带来一些隐藏的陷阱，接下来会一一提到。</p>
<blockquote>
<p><a href="https://cn.vuejs.org/v2/guide/components.html#非父子组件通信" target="_blank" rel="external">官方文档 &gt;</a></p>
</blockquote>
<h3 id="异常触发事件"><a href="#异常触发事件" class="headerlink" title="异常触发事件"></a>异常触发事件</h3><h4 id="文档结构-amp-场景"><a href="#文档结构-amp-场景" class="headerlink" title="文档结构&amp;场景"></a>文档结构&amp;场景</h4><h5 id="文档结构"><a href="#文档结构" class="headerlink" title="文档结构"></a>文档结构</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">.</div><div class="line">├── componentA.vue</div><div class="line">├── componentB.vue</div><div class="line">└── eventBus.js</div></pre></td></tr></table></figure>
<h5 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">routes: [</div><div class="line">    &#123;</div><div class="line">      <span class="attr">path</span>: <span class="string">'/componentA'</span>,</div><div class="line">      <span class="attr">name</span>: <span class="string">'componentA'</span>,</div><div class="line">      <span class="attr">component</span>: componentA</div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">      <span class="attr">path</span>: <span class="string">'/'</span>,</div><div class="line">      <span class="attr">redirect</span>: &#123; <span class="attr">path</span>: <span class="string">'/componentA'</span> &#125;</div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">      <span class="attr">path</span>: <span class="string">'/componentB'</span>,</div><div class="line">      <span class="attr">name</span>: <span class="string">'componentB'</span>,</div><div class="line">      <span class="attr">component</span>: componentB</div><div class="line">    &#125;</div><div class="line">  ]</div></pre></td></tr></table></figure>
<h4 id="行为描述"><a href="#行为描述" class="headerlink" title="行为描述"></a>行为描述</h4><ul>
<li>声明一个单文件的vue实例 eventBus</li>
<li>分别在组件A和组件B里导入eventBus</li>
<li>在组件A<code>mounted</code>时，在eventBus上<code>$on</code>一个<code>message</code>事件</li>
<li>在组件B内设置一个按钮，点击可以<code>$emit</code>eventBus上的<code>message</code>事件</li>
<li>在两个组件的<code>beforeDestroy</code>的声明周期内打出相应讯息</li>
</ul>
<h5 id="期望结果"><a href="#期望结果" class="headerlink" title="期望结果"></a>期望结果</h5><p>在组件A和组件B之间通过路由切换时，点击组件B内按钮，正常触发<code>message</code>事件</p>
<h5 id="实际结果"><a href="#实际结果" class="headerlink" title="实际结果"></a>实际结果</h5><p><img src="http://7xw3pf.com1.z0.glb.clouddn.com/vue-eventBus%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-08-14%20%E4%B8%8B%E5%8D%8812.07.00.png" alt="运行结果"><br><b>说明：在第二次从组件A切换到组件B时，点击按钮，出现了两次’message’事件被触发的效果，当组件A第N次切换到组件B时，点击按钮，出现了N次’message’事件被触发的效果</b></p>
<h4 id="推测"><a href="#推测" class="headerlink" title="推测"></a>推测</h4><p>组件的销毁不能使eventBus里的事件销毁。并且当组件再次创建时，同名事件不覆盖，会被再次注册绑定。导致看起来是多次触发了同一事件，实际上是同时触发了多个同名事件。</p>
<h4 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h4><h5 id="解绑事件"><a href="#解绑事件" class="headerlink" title="解绑事件"></a>解绑事件</h5><p>做法：在组件A的beforeDestroy周期，解绑事件<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">beforeDestroy: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	eventBus.$off(<span class="string">'message'</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>结果：达到期望结果<br>解决推测：组件销毁时事件没被销毁</p>
<h5 id="非全局eventBus使用"><a href="#非全局eventBus使用" class="headerlink" title="非全局eventBus使用"></a>非全局eventBus使用</h5><p>做法：增加一个父组件componentParent,在父组件中声明eventBus，并以prop方式传递给组件A和组件B，在组件A销毁时销毁<br>结果：达到期望结果<br>解决推测：事件不销毁是挂载的eventBus没被销毁导致的</p>
<h5 id="同名事件"><a href="#同名事件" class="headerlink" title="同名事件"></a>同名事件</h5><p>做法：在组件A内绑定一个同名事件<code>message</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// componentA</span></div><div class="line">mounted: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">this</span>.$nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		eventBus.$on(<span class="string">'message'</span>, (params) =&gt; <span class="keyword">this</span>.func(params))</div><div class="line">		);</div><div class="line">		eventBus.$on(<span class="string">'message'</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'再次绑定了message事件'</span>));</div><div class="line">	&#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>结果：点击按钮时，<code>console.log</code>两次,说明两个事件都被触发了。<br>解决推测：同名事件不会被覆盖</p>
<h5 id="keep-alive的影响"><a href="#keep-alive的影响" class="headerlink" title="keep-alive的影响"></a>keep-alive的影响</h5><p>做法：在组件A和组件B的<code>&lt;router-view&gt;</code>前增加<code>&lt;keep-alive&gt;</code>标签，保持组件在路由切换时不被销毁<br>结果：达到期望结果<br>解决推测：组件销毁-创建会重复注册事件</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>由以上实践可知</p>
<ul>
<li>全局（文件式）eventBus上的事件不会随着组件的销毁而销毁</li>
<li>eventBus允许同名事件存在</li>
<li>组件被重新创建会再次绑定注册事件</li>
</ul>
<h3 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h3><p>事件解绑是必要的，之前写代码没有这方面的意识，这次踩坑发现了，写代码要严谨，考虑清楚在组件的各个声明周期内要做什么。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;eventBus是一个vue实例，上面挂载了许多监听事件，通过触发相应的监听事件，可以实现不同层级的组件之间的通信。&lt;br&gt;
    
    </summary>
    
      <category term="血的教训" scheme="https://escawn.github.io/categories/%E8%A1%80%E7%9A%84%E6%95%99%E8%AE%AD/"/>
    
    
      <category term="vue" scheme="https://escawn.github.io/tags/vue/"/>
    
      <category term="坑" scheme="https://escawn.github.io/tags/%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>【踩坑】空数组居然不执行every()方法！</title>
    <link href="https://escawn.github.io/2017/08/03/%E3%80%90%E8%B8%A9%E5%9D%91%E3%80%91%E7%A9%BA%E6%95%B0%E7%BB%84%E5%B1%85%E7%84%B6%E4%B8%8D%E6%89%A7%E8%A1%8Cevery-%E6%96%B9%E6%B3%95%EF%BC%81/"/>
    <id>https://escawn.github.io/2017/08/03/【踩坑】空数组居然不执行every-方法！/</id>
    <published>2017-08-03T11:11:30.000Z</published>
    <updated>2017-08-03T11:24:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>空数组不执行<code>every()</code>方法？？？<br><a id="more"></a></p>
<h4 id="一张图描述问题"><a href="#一张图描述问题" class="headerlink" title="一张图描述问题"></a>一张图描述问题</h4><p><img src="http://7xw3pf.com1.z0.glb.clouddn.com/%E8%B8%A9%E5%9D%91%E7%A9%BA%E6%95%B0%E7%BB%84.png" alt=""></p>
<h4 id="一张图解决问题"><a href="#一张图解决问题" class="headerlink" title="一张图解决问题"></a>一张图解决问题</h4><p><img src="http://7xw3pf.com1.z0.glb.clouddn.com/%E8%B8%A9%E5%9D%91%E7%A9%BA%E6%95%B0%E7%BB%842.png" alt=""></p>
<p>来自<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every" target="_blank" rel="external">MDN</a></p>
<h4 id="一句话总结"><a href="#一句话总结" class="headerlink" title="一句话总结"></a>一句话总结</h4><p>由第一张图可以了解，<code>every</code>方法遇到空数组，并没有往里执行，而是直接返回了<code>true</code></p>
<h4 id="一句话反省"><a href="#一句话反省" class="headerlink" title="一句话反省"></a>一句话反省</h4><p>注意特殊临界值（空数组、空对象、undefined、null），多查文档</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;空数组不执行&lt;code&gt;every()&lt;/code&gt;方法？？？&lt;br&gt;
    
    </summary>
    
      <category term="血的教训" scheme="https://escawn.github.io/categories/%E8%A1%80%E7%9A%84%E6%95%99%E8%AE%AD/"/>
    
    
      <category term="坑" scheme="https://escawn.github.io/tags/%E5%9D%91/"/>
    
      <category term="js" scheme="https://escawn.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>Vue-devtools无法启动的几个原因&amp;解决方案</title>
    <link href="https://escawn.github.io/2017/07/30/Vue-devtools%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8%E7%9A%84%E5%87%A0%E4%B8%AA%E5%8E%9F%E5%9B%A0-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>https://escawn.github.io/2017/07/30/Vue-devtools无法启动的几个原因-解决方案/</id>
    <published>2017-07-30T07:57:02.000Z</published>
    <updated>2017-07-30T08:46:34.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><blockquote>
<p>vue-devtools是一款基于chrome浏览器的调试vue.js应用的扩展程序</p>
</blockquote>
<a id="more"></a>
<p>长这样：<br><img src="https://raw.githubusercontent.com/vuejs/vue-devtools/master/media/screenshot.png" alt=""></p>
<p><a href="https://github.com/vuejs/vue-devtools" target="_blank" rel="external">安装及介绍在这</a></p>
<h3 id="原因-amp-解决"><a href="#原因-amp-解决" class="headerlink" title="原因&amp;解决"></a>原因&amp;解决</h3><h4 id="正常情况"><a href="#正常情况" class="headerlink" title="正常情况"></a>正常情况</h4><p>正常情况下，使用vue-devtools进行调试，如上图，主要有两个条件</p>
<ol>
<li>右上角chrome扩展的vue标识亮，这表示当前页面检测到引用了vue文件</li>
<li>chrome调试窗口出现vue一栏，这表示能够对当前页面进行调试</li>
</ol>
<p>如果1不正常，则一定不会出现2，即1是2的必要条件，由这两点出发，看看”不出问题的人是相似的，出问题的人则各有各的问（bu）题（xing）”是个什么情况</p>
<h4 id="右上角vue标识变灰"><a href="#右上角vue标识变灰" class="headerlink" title="右上角vue标识变灰"></a>右上角vue标识变灰</h4><p>点击时会出现提示，Vue.js not detected.(未检测到vue.js)</p>
<p>可是我明明用了vue呀，怎么回事？</p>
<h5 id="chrome扩展程序选项的问题"><a href="#chrome扩展程序选项的问题" class="headerlink" title="chrome扩展程序选项的问题"></a>chrome扩展程序选项的问题</h5><p>打开chrome的扩展程序管理界面，检查</p>
<ul>
<li>已启用按钮是否勾选</li>
<li>允许访问文件地址是否勾选</li>
<li>在隐身模式下启用是否勾选（如果你习惯于使用chrome的隐身模式）</li>
</ul>
<h5 id="vue-js引入版本"><a href="#vue-js引入版本" class="headerlink" title="vue.js引入版本"></a>vue.js引入版本</h5><p>我们在开发和部署代码时，可能引用不同方式打包的vue文件，比如vue.js、vue.min.js、vue.esm.js等。实际上，vue devtools所能检测的vue文件会受到版本的限制，比如后两者方式打包的vue极有可能不会被检测出来（还会受到vue本身版本的限制）。</p>
<p>所以建议是，在开发环境下，引用稳定版本的vue.js，在考虑性能的生产环境，再根据需要选择。</p>
<h4 id="chrome调试窗口不出现vue一栏"><a href="#chrome调试窗口不出现vue一栏" class="headerlink" title="chrome调试窗口不出现vue一栏"></a>chrome调试窗口不出现vue一栏</h4><p>这种情况下，右上角扩展栏vue标识会变亮，点击显示</p>
<blockquote>
<p>Vue.js is detected on this page. Devtools inspection is not available because it’s in production mode or explicitly disabled by the author.</p>
</blockquote>
<p>意为生产模式&amp;开发者禁用devtools。</p>
<p>这个时候需要显式地设置devtools可用。在代码文件里加入<code>Vue.config.devtools = true</code>。</p>
<h4 id="重启-amp-刷新"><a href="#重启-amp-刷新" class="headerlink" title="重启&amp;刷新"></a>重启&amp;刷新</h4><p>如果做完以上排查，仍然不可用。需要考虑重启&amp;刷新。</p>
<p>比如代码修改后是否重启服务器，是否刷新页面并重启chorme调试窗口。</p>
<h4 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h4><p>如果还有问题，可以考虑<a href="https://github.com/vuejs/vue-devtools/issues" target="_blank" rel="external">向vue devtools的github提交issue</a></p>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;vue-devtools是一款基于chrome浏览器的调试vue.js应用的扩展程序&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="经验总结" scheme="https://escawn.github.io/categories/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="vue" scheme="https://escawn.github.io/tags/vue/"/>
    
      <category term="vue-devtools" scheme="https://escawn.github.io/tags/vue-devtools/"/>
    
  </entry>
  
  <entry>
    <title>webpack进阶学习</title>
    <link href="https://escawn.github.io/2017/07/20/webpack%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://escawn.github.io/2017/07/20/webpack学习笔记/</id>
    <published>2017-07-20T11:23:42.000Z</published>
    <updated>2017-07-25T09:27:09.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>webpack是当下流行的前端工程打包工具，本文较深入地分析了其运作原理，以及一些常用功能的实现思路。<br><a id="more"></a></p>
<hr>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><blockquote>
<p>Webpack 是当下最热门的前端资源模块化管理和打包工具。它可以将许多松散的模块按照依赖和规则打包成符合生产环境部署的前端资源。还可以将按需加载的模块进行代码分隔，等到实际需要的时候再异步加载。通过 loader 的转换，任何形式的资源都可以视作模块，比如 CommonJs 模块、 AMD 模块、 ES6 模块、CSS、图片、 JSON、Coffeescript、 LESS 等。</p>
</blockquote>
<h3 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h3><h4 id="Entry"><a href="#Entry" class="headerlink" title="Entry"></a>Entry</h4><h5 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h5><p>在<code>webpack.config.js</code>中配置，含义为指定注入webpack的文件，由这个文件引出的依赖集合导向一个自命名<code>chunk</code>，默认名为<code>main</code>。webpack将从这个文件开始，一步步分析模块依赖，并进行模块的处理。</p>
<h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><p>entry是一个对象，对象里键值对的形式为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">entry: &#123;</div><div class="line">	chunkName: entry file&apos;s path</div><div class="line">&#125;</div><div class="line">// 如</div><div class="line">entry: &#123;</div><div class="line">    main: &apos;./path/to/my/entry/file.js&apos;</div><div class="line">  &#125;</div><div class="line">// 多文件入口</div><div class="line">entry: &#123;</div><div class="line">    app: &apos;./src/app.js&apos;,</div><div class="line">    vendors: &apos;./src/vendors.js&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>多文件入口用于chunk形成的依赖图是独立的情况下，多用于单页面应用+第三方库或多页面应用的情况下。</p>
<h4 id="Chunks"><a href="#Chunks" class="headerlink" title="Chunks"></a>Chunks</h4><h5 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h5><p>chunk是webpack代码分离(code splitting)的产物，里面装载了一系列具有依赖关系的模块。</p>
<h5 id="chunk类别"><a href="#chunk类别" class="headerlink" title="chunk类别"></a>chunk类别</h5><ul>
<li><p>entry chunk：入口代码块包含了 webpack 运行时需要的一些函数，以及依赖的一系列模块。通过<code>output.filename</code>配置输出</p>
</li>
<li><p>normal chunk：普通代码块（又名非主入口文件）没有包含运行时需要的代码，主要指代那些应用运行时动态加载（比如<code>require.ensure</code>）的模块。</p>
</li>
<li><p>initial chunk：通过<code>output.chunkfilename</code>配置输出，是这个插件提取共有模块形成的chunk,其会在应用初始化时完成加载</p>
</li>
</ul>
<h5 id="对应关系"><a href="#对应关系" class="headerlink" title="对应关系"></a>对应关系</h5><p>以下chunk均指entry chunk</p>
<ul>
<li>chunk &amp; entry file：一个入口文件对应一个chunk，由入口文件引出的依赖集合导向一个chunk。但是chunk不仅由入口文件导出，提取公共模块、动态加载模块也可生成chunk</li>
<li>chunk &amp; bundle：默认情况下一个chunk最终导出一个同名bundle文件</li>
</ul>
<h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><h5 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h5><p>控制 webpack 如何向硬盘写入编译文件</p>
<h5 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h5><p>一个对象，至少含有键为<code>filename</code>和<code>path</code>的两个键值对</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">output: &#123;</div><div class="line">    <span class="attr">filename</span>: <span class="string">'bundle.js'</span>,</div><div class="line">    <span class="attr">path</span>: <span class="string">'/home/proj/public/assets'</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// 当有多个入口，使用占位符自动配置成与chunkName同名的出口文件名字和路径</span></div><div class="line">output: &#123;</div><div class="line">    <span class="attr">filename</span>: <span class="string">'[name].js'</span>,</div><div class="line">    <span class="attr">path</span>: __dirname + <span class="string">'/dist'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Bundle"><a href="#Bundle" class="headerlink" title="Bundle"></a>Bundle</h4><p>bundle是 webpack 打包后的产物，可以通过配置设置其在硬盘中的存储位置。<br>一般一个bundle对应一个chunk。</p>
<p>使用webpack-dev-server进行开发时，编译在内存中进行，bundle不存储在硬盘中.</p>
<h4 id="Loader"><a href="#Loader" class="headerlink" title="Loader"></a>Loader</h4><h5 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h5><p>loader 用于对模块的源代码进行转换。将其他类型的资源转换成js模块，交给webpack处理</p>
<h5 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h5><ol>
<li>支持链式调用，一个loader的输出可以是另一个Loader的输入</li>
<li>可以同步或异步执行</li>
<li>可以接受参数</li>
<li>通过文件扩展名（正则）绑定不同类型的文件</li>
<li>通过npm发布和安装</li>
<li>可以自己书写loader，作为一个模块导出使用</li>
</ol>
<h5 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h5><p>loader的配置挂在<code>module.rules（array）</code>下，webpack 允许配置多个loader，可选并不限于以下键值对</p>
<ul>
<li>匹配类（必）：匹配文件来应用规则，如<code>test</code>(正则语法，多用于文件后缀的匹配)，<code>include</code>（string或array，多用于文件路径的匹配），<code>enclude</code>（string或array，剔除匹配的文件）</li>
<li><code>loader</code>（必）：值为loader name（string），多为<code>xxx-loader</code>的形式</li>
<li><code>enforce</code>（非必）：值为<code>pre</code>|<code>post</code>，指定 loader 种类。所有 loader 通过 后置, 行内, 普通, 前置 排序，并按此顺序使用。</li>
<li><code>options</code>（非必）：值为string或object，值可以传递到 loader 中，将其理解为 loader 选项。</li>
<li><code>parse</code>（非必）：值为object，是解析选项配置的集合，配置完成之后，相关插件可以被启用。如<code>commonJs：false</code>表示禁用CommonJs</li>
</ul>
<p>示例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">module: &#123;</div><div class="line">  rules: [</div><div class="line">    // 匹配后缀为图片类的文件</div><div class="line">    test: /\.(png|jpe?g|gif|svg)(\?.*)?$/,</div><div class="line">    // 应用url-loader</div><div class="line">    loader: &apos;url-loader&apos;,</div><div class="line">    // 配置传递给loader的选项</div><div class="line">    options: &#123;</div><div class="line">      limit: 10000,</div><div class="line">      name: utils.assetsPath(&apos;img/[name].[hash:7].[ext]&apos;)</div><div class="line">    &#125;</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Plugin"><a href="#Plugin" class="headerlink" title="Plugin"></a>Plugin</h4><h5 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h5><p>plugin是webpack核心支柱功能，通过plugin（插件）webpack可以实现loader所不能完成的复杂功能，使用plugin丰富的自定义API以及生命周期事件，可以控制webpack编译流程的每个环节，实现对webpack的自定义功能扩展。</p>
<h5 id="原理概览"><a href="#原理概览" class="headerlink" title="原理概览"></a>原理概览</h5><blockquote>
<p>插件是一个具有<code>apply</code>方法的 JavaScript 对象。webpack有一个实现插件绑定与调用的库（<code>tapable</code>），贯穿整个webpack打包编译过程。不同的插件通过自身的<code>apply</code>方法调用<code>tapable</code>的<code>plugin</code>方法，将插件添加到<code>compiler</code>对象，<code>compiler</code>对象可在整个编译生命周期访问，插件从而实现在编译的不同时期对文件进行相应的处理。</p>
</blockquote>
<h5 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h5><ul>
<li>先安装: <code>npm install --save html-webpack-plugin</code></li>
<li>再导入：<code>const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;)</code></li>
<li><p>最后配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">plugins: [</div><div class="line">	 // 各个插件配置时需要的参数不一，请参考官方文档</div><div class="line">  new webpack.optimize.UglifyJsPlugin(),</div><div class="line">  new HtmlWebpackPlugin(&#123;template: &apos;./src/index.html&apos;&#125;)</div><div class="line">]</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h4><h5 id="介绍-5"><a href="#介绍-5" class="headerlink" title="介绍"></a>介绍</h5><p>模块是实现特定功能的功能块。webpack的核心理念就是<code>一切皆模块</code>,将所有资源以及文件转化为模块。</p>
<h5 id="webpack中的模块类型"><a href="#webpack中的模块类型" class="headerlink" title="webpack中的模块类型"></a>webpack中的模块类型</h5><blockquote>
<ul>
<li>ES2015 import 语句</li>
<li>CommonJS require() 语句</li>
<li>AMD define 和 require 语句</li>
<li>css/sass/less 文件中的 @import 语句。</li>
<li>样式(url(…))或 HTML 文件 <img src="...">中的图片链接(image url)</li>
</ul>
</blockquote>
<h3 id="配置应用"><a href="#配置应用" class="headerlink" title="配置应用"></a>配置应用</h3><h4 id="基础文件结构"><a href="#基础文件结构" class="headerlink" title="基础文件结构"></a>基础文件结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">├── node-modules</div><div class="line">├── package.json</div><div class="line">├── dist</div><div class="line">│   └── bundle.js 	  	 // webpack打包好的文件</div><div class="line">├── src</div><div class="line">│   └── entry.js 		 // webpack打包的入口文件</div><div class="line">├── webpack.config.js    // webpack配置文件</div><div class="line">└── index.html 			 // 主页面，通过script标签将bundle引入</div></pre></td></tr></table></figure>
<h4 id="webpack-config-js详解"><a href="#webpack-config-js详解" class="headerlink" title="webpack.config.js详解"></a>webpack.config.js详解</h4><p><code>webpack.config.js</code>是一个node.js模块，导出json格式的配置信息对象</p>
<p>包含要配置的内容：</p>
<ul>
<li><code>entry</code></li>
<li><code>output</code></li>
<li><code>loader</code></li>
<li><code>plugin</code></li>
<li><code>resolve</code></li>
</ul>
<h5 id="详细示例"><a href="#详细示例" class="headerlink" title="详细示例"></a>详细示例</h5><p>通过vue-cli创建项目，build文件夹下自动生成四个webpack配置文件</p>
<ul>
<li><code>webpack.base.conf.js</code>：基础，或者说公共webpack配置</li>
<li><code>webpack.dev.conf.js</code>：开发环境下的webpack配置</li>
<li><code>webpack.prod.conf.js</code>：生成环境下的webpack配置</li>
<li><code>webpack.test.conf.js</code>：测试阶段的webpack配置</li>
</ul>
<p>这里主要关注前三个配置文件</p>
<h6 id="webpack-base-conf-js"><a href="#webpack-base-conf-js" class="headerlink" title="webpack.base.conf.js"></a><code>webpack.base.conf.js</code></h6><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</div><div class="line"><span class="keyword">var</span> utils = <span class="built_in">require</span>(<span class="string">'./utils'</span>)</div><div class="line"><span class="keyword">var</span> config = <span class="built_in">require</span>(<span class="string">'../config'</span>)</div><div class="line"><span class="keyword">var</span> vueLoaderConfig = <span class="built_in">require</span>(<span class="string">'./vue-loader.conf'</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolve</span> (<span class="params">dir</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> path.join(__dirname, <span class="string">'..'</span>, dir)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  <span class="attr">entry</span>: &#123;                                                <span class="comment">// 配置入口文件</span></div><div class="line">	app: <span class="string">'./src/main.js'</span>                                  <span class="comment">// app为chunk名，'./src/main.js'为文件路径</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">output</span>: &#123;</div><div class="line">    <span class="attr">path</span>: config.build.assetsRoot,                        <span class="comment">//  打包好的文件储存路径  </span></div><div class="line">    filename: <span class="string">'[name].js'</span>,                                <span class="comment">//  表示根据入口文件的chunk name自动生成对应名字的bundle</span></div><div class="line">    publicPath: process.env.NODE_ENV === <span class="string">'production'</span>     <span class="comment">//  通过判断是否在生产环境下制定内嵌文件（如css、图片）的路径前缀</span></div><div class="line">      ? config.build.assetsPublicPath</div><div class="line">      : config.dev.assetsPublicPath</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">resolve</span>: &#123;                                              <span class="comment">//  配置模块路径的解析器</span></div><div class="line">    extensions: [<span class="string">'.js'</span>, <span class="string">'.vue'</span>, <span class="string">'.json'</span>],                 <span class="comment">//  表示解析器支持以下文件后缀名的文件解析</span></div><div class="line">    alias: &#123;                                              <span class="comment">//  创建模块别名代替路径名</span></div><div class="line">      <span class="string">'vue$'</span>: <span class="string">'vue/dist/vue.esm.js'</span>,                      <span class="comment">//  import或require`vue.esm.js`文件时，可用`vue$`代替</span></div><div class="line">      <span class="string">'@'</span>: resolve(<span class="string">'src'</span>)                                 <span class="comment">//  import或require ‘src’文件夹下的模块时，可用'@'作为路径代替  </span></div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">module</span>: &#123;</div><div class="line">    <span class="attr">rules</span>: [                                              <span class="comment">//  webpack2&amp;webpack3中通过module.rules设置loader</span></div><div class="line">      &#123;</div><div class="line">        <span class="attr">test</span>: <span class="regexp">/\.(js|vue)$/</span>,                              <span class="comment">//  匹配js和vue为后缀的文件，应用此条rule</span></div><div class="line">        loader: <span class="string">'eslint-loader'</span>,                          <span class="comment">//  使用eslint-loader作为转换器</span></div><div class="line">        enforce: <span class="string">'pre'</span>,                                   <span class="comment">//  enforce指定loader种类，pre表示此loader最先执行</span></div><div class="line">        include: [resolve(<span class="string">'src'</span>), resolve(<span class="string">'test'</span>)],       <span class="comment">//  匹配此文件夹下的资源</span></div><div class="line">        options: &#123;                                        <span class="comment">//  loader选项，里面的值可以传到loader中</span></div><div class="line">          formatter: <span class="built_in">require</span>(<span class="string">'eslint-friendly-formatter'</span>) <span class="comment">//  代码检查配置工具</span></div><div class="line">        &#125;</div><div class="line">      &#125;,</div><div class="line">      &#123;</div><div class="line">        <span class="attr">test</span>: <span class="regexp">/\.vue$/</span>,                                   <span class="comment">//  解析vue为后缀的文件，使用vue-loader转换</span></div><div class="line">        loader: <span class="string">'vue-loader'</span>,</div><div class="line">        <span class="attr">options</span>: vueLoaderConfig</div><div class="line">      &#125;,</div><div class="line">      &#123;</div><div class="line">        <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,                                    <span class="comment">//  解析js为后缀的文件，使用babel-loader转换（针对es6语法）</span></div><div class="line">        loader: <span class="string">'babel-loader'</span>,</div><div class="line">        <span class="attr">include</span>: [resolve(<span class="string">'src'</span>), resolve(<span class="string">'test'</span>)]</div><div class="line">      &#125;,</div><div class="line">      &#123;</div><div class="line">        <span class="attr">test</span>: <span class="regexp">/\.(png|jpe?g|gif|svg)(\?.*)?$/</span>,            <span class="comment">//  转换图片类文件</span></div><div class="line">        loader: <span class="string">'url-loader'</span>,</div><div class="line">        <span class="attr">options</span>: &#123;</div><div class="line">          <span class="attr">limit</span>: <span class="number">10000</span>,                                   <span class="comment">//  限制文件的url字节</span></div><div class="line">          name: utils.assetsPath(<span class="string">'img/[name].[hash:7].[ext]'</span>)</div><div class="line">        &#125;</div><div class="line">      &#125;,</div><div class="line">      &#123;</div><div class="line">        <span class="attr">test</span>: <span class="regexp">/\.(mp4|webm|ogg|mp3|wav|flac|aac)(\?.*)?$/</span>,<span class="comment">//  转换音视频类文件</span></div><div class="line">        loader: <span class="string">'url-loader'</span>,</div><div class="line">        <span class="attr">options</span>: &#123;</div><div class="line">          <span class="attr">limit</span>: <span class="number">10000</span>,                                   <span class="comment">//  限制文件的url字节</span></div><div class="line">          name: utils.assetsPath(<span class="string">'media/[name].[hash:7].[ext]'</span>)     </div><div class="line">        &#125;</div><div class="line">      &#125;,</div><div class="line">      &#123;</div><div class="line">        <span class="attr">test</span>: <span class="regexp">/\.(woff2?|eot|ttf|otf)(\?.*)?$/</span>,           <span class="comment">//  转换字体类文件</span></div><div class="line">        loader: <span class="string">'url-loader'</span>,</div><div class="line">        <span class="attr">options</span>: &#123;</div><div class="line">          <span class="attr">limit</span>: <span class="number">10000</span>,</div><div class="line">          <span class="attr">name</span>: utils.assetsPath(<span class="string">'fonts/[name].[hash:7].[ext]'</span>)</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br><br><br></p>
<h6 id="webpack-dev-conf-js"><a href="#webpack-dev-conf-js" class="headerlink" title="webpack.dev.conf.js"></a><code>webpack.dev.conf.js</code></h6><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// dev-client文件里封装了与hot-reload相关的代码，将它们加进entry chunk里</span></div><div class="line"><span class="built_in">Object</span>.keys(baseWebpackConfig.entry).forEach(<span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</div><div class="line">  baseWebpackConfig.entry[name] = [<span class="string">'./build/dev-client'</span>].concat(baseWebpackConfig.entry[name])</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// merge webpack基础配置</span></div><div class="line"><span class="built_in">module</span>.exports = merge(baseWebpackConfig, &#123;</div><div class="line">  <span class="attr">module</span>: &#123;</div><div class="line"></div><div class="line">    <span class="comment">// 生成源文件和压缩文件对应的sourceMap</span></div><div class="line">    rules: utils.styleLoaders(&#123; <span class="attr">sourceMap</span>: config.dev.cssSourceMap &#125;)</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  <span class="comment">// cheap-module-eval-source-map is faster for development</span></div><div class="line">  <span class="comment">// 选用此配置作为sourceMap的构建工具,这个工具会帮助在chrome下显示源码文件</span></div><div class="line">  devtool: <span class="string">'#cheap-module-eval-source-map'</span>,</div><div class="line">  <span class="attr">plugins</span>: [</div><div class="line"></div><div class="line">    <span class="comment">// 定义开发环境,代码中任何出现 process.env的地方都会被替换为config.dev.env</span></div><div class="line">    <span class="keyword">new</span> webpack.DefinePlugin(&#123;</div><div class="line">      <span class="string">'process.env'</span>: config.dev.env</div><div class="line">    &#125;),</div><div class="line"></div><div class="line">    <span class="comment">// https://github.com/glenjamin/webpack-hot-middleware#installation--usage</span></div><div class="line">    <span class="comment">// 此插件用于在应用程序运行过程中代码修改时，只修改相关模块而无需重新加载整个页面</span></div><div class="line">    <span class="keyword">new</span> webpack.HotModuleReplacementPlugin(),</div><div class="line"></div><div class="line">    <span class="comment">// 使用此插件在编译出现错误时跳过输出阶段。这样可以确保输出资源不会包含错误。</span></div><div class="line">    <span class="keyword">new</span> webpack.NoEmitOnErrorsPlugin(),</div><div class="line"></div><div class="line">    <span class="comment">// https://github.com/ampedandwired/html-webpack-plugin</span></div><div class="line">    <span class="comment">// 此插件用于自动生成html文件，不需要手动创建，再通过script标签引入打包后的bundle</span></div><div class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</div><div class="line">      <span class="attr">filename</span>: <span class="string">'index.html'</span>,</div><div class="line">      <span class="attr">template</span>: <span class="string">'index.html'</span>,</div><div class="line">      <span class="attr">inject</span>: <span class="literal">true</span></div><div class="line">    &#125;),</div><div class="line"></div><div class="line">    <span class="comment">// 此插件用于识别、汇总、清理报错</span></div><div class="line">    <span class="keyword">new</span> FriendlyErrorsPlugin()</div><div class="line">  ]</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p><br><br><br></p>
<h6 id="webpack-prod-conf-js"><a href="#webpack-prod-conf-js" class="headerlink" title="webpack.prod.conf.js"></a><code>webpack.prod.conf.js</code></h6><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// merge webpack基础配置</span></div><div class="line"><span class="keyword">var</span> webpackConfig = merge(baseWebpackConfig, &#123;</div><div class="line">  <span class="attr">module</span>: &#123;</div><div class="line">    <span class="comment">// utils模块里封装了样式处理loader，可传入两个键值对，是否开启sourceMap和是否启用插件ExtractTextWebpackPlugin</span></div><div class="line">    rules: utils.styleLoaders(&#123;</div><div class="line">      <span class="attr">sourceMap</span>: config.build.productionSourceMap,</div><div class="line">      <span class="comment">// 意为将所有的入口 chunk(entry chunks)中引用的样式文件，移动到独立分离的 CSS 文件</span></div><div class="line">      extract: <span class="literal">true</span></div><div class="line">    &#125;)</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  <span class="comment">// 使用source-map作为sourceMap的构建工具</span></div><div class="line">  devtool: config.build.productionSourceMap ? <span class="string">'#source-map'</span> : <span class="literal">false</span>,</div><div class="line"></div><div class="line">  <span class="comment">// 定义output导出路径</span></div><div class="line">  output: &#123;</div><div class="line">    <span class="attr">path</span>: config.build.assetsRoot,</div><div class="line">    <span class="attr">filename</span>: utils.assetsPath(<span class="string">'js/[name].[chunkhash].js'</span>),</div><div class="line">    <span class="comment">// 非主入口文件的命名规则，非主入口文件一般出现在require.ensure加载模块的时候（异步加载模块，而未给入口文件）</span></div><div class="line">    chunkFilename: utils.assetsPath(<span class="string">'js/[id].[chunkhash].js'</span>)</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  <span class="attr">plugins</span>: [</div><div class="line">    <span class="comment">// http://vuejs.github.io/vue-loader/en/workflow/production.html</span></div><div class="line">    <span class="comment">// 定义生产环境,代码中任何出现 process.env的地方都会被替换为env</span></div><div class="line">    <span class="keyword">new</span> webpack.DefinePlugin(&#123;</div><div class="line">      <span class="string">'process.env'</span>: env</div><div class="line">    &#125;),</div><div class="line"></div><div class="line">    <span class="comment">// 混淆代码</span></div><div class="line">    <span class="keyword">new</span> webpack.optimize.UglifyJsPlugin(&#123;</div><div class="line">      <span class="attr">compress</span>: &#123;</div><div class="line">        <span class="attr">warnings</span>: <span class="literal">false</span></div><div class="line">      &#125;,</div><div class="line">      <span class="attr">sourceMap</span>: <span class="literal">true</span></div><div class="line">    &#125;),</div><div class="line"></div><div class="line">    <span class="comment">// extract css into its own file</span></div><div class="line">    <span class="comment">// 将所有的入口chunk中引用的样式*.css，移动到独立分离的 CSS 文件。</span></div><div class="line">    <span class="keyword">new</span> ExtractTextPlugin(&#123;</div><div class="line">      <span class="attr">filename</span>: utils.assetsPath(<span class="string">'css/[name].[contenthash].css'</span>)</div><div class="line">    &#125;),</div><div class="line"></div><div class="line">    <span class="comment">// Compress extracted CSS. We are using this plugin so that possible</span></div><div class="line">    <span class="comment">// duplicated CSS from different components can be deduped.</span></div><div class="line">    <span class="comment">// 压缩独立的css样式文件代码，并进行优化</span></div><div class="line">    <span class="keyword">new</span> OptimizeCSSPlugin(&#123;</div><div class="line">      <span class="attr">cssProcessorOptions</span>: &#123;</div><div class="line">        <span class="attr">safe</span>: <span class="literal">true</span></div><div class="line">      &#125;</div><div class="line">    &#125;),</div><div class="line"></div><div class="line">    <span class="comment">// generate dist index.html with correct asset hash for caching.</span></div><div class="line">    <span class="comment">// you can customize output by editing /index.html</span></div><div class="line">    <span class="comment">// see https://github.com/ampedandwired/html-webpack-plugin</span></div><div class="line">    <span class="comment">// 此插件用于自动生成html文件，不需要手动创建，再通过script标签引入打包后的bundle</span></div><div class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</div><div class="line">    	<span class="comment">// 生产的html的名字</span></div><div class="line">      filename: process.env.NODE_ENV === <span class="string">'testing'</span></div><div class="line">        ? <span class="string">'index.html'</span></div><div class="line">        : config.build.index,</div><div class="line">      <span class="attr">template</span>: <span class="string">'index.html'</span>,</div><div class="line">      <span class="comment">// 表示js资源将放在&lt;body&gt;的底部</span></div><div class="line">      inject: <span class="literal">true</span>,</div><div class="line">      <span class="comment">// 减少输出的配置选项</span></div><div class="line">      minify: &#123;</div><div class="line">      	  <span class="comment">// 移除html注释</span></div><div class="line">        removeComments: <span class="literal">true</span>,</div><div class="line">        <span class="comment">// 折叠会产生文档树节点的空格</span></div><div class="line">        collapseWhitespace: <span class="literal">true</span>,</div><div class="line">        <span class="comment">// 尽可能删除属性的引号</span></div><div class="line">        removeAttributeQuotes: <span class="literal">true</span></div><div class="line">        <span class="comment">// more options:</span></div><div class="line">        <span class="comment">// https://github.com/kangax/html-minifier#options-quick-reference</span></div><div class="line">      &#125;,</div><div class="line">      <span class="comment">// necessary to consistently work with multiple chunks via CommonsChunkPlugin</span></div><div class="line">      <span class="comment">// 控制如何将chunk块在html中进行排序</span></div><div class="line">      chunksSortMode: <span class="string">'dependency'</span></div><div class="line">    &#125;),</div><div class="line">    <span class="comment">// split vendor js into its own file</span></div><div class="line"></div><div class="line">    <span class="comment">// 将多个入口起点之间共享的公共模块，生成为一些 chunk，并且分离到单独的 bundle 中</span></div><div class="line">    <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</div><div class="line">      <span class="attr">name</span>: <span class="string">'vendor'</span>,</div><div class="line">      <span class="comment">// minChunks这个函数会被 CommonsChunkPlugin 插件回调，并且调用函数时会传入 module 和 count 参数。控制决定模块被打包到哪里的算法</span></div><div class="line">      minChunks: <span class="function"><span class="keyword">function</span> (<span class="params">module, count</span>) </span>&#123;</div><div class="line">        <span class="comment">// any required modules inside node_modules are extracted to vendor</span></div><div class="line">        <span class="keyword">return</span> (</div><div class="line">          <span class="built_in">module</span>.resource &amp;&amp;</div><div class="line">          <span class="regexp">/\.js$/</span>.test(<span class="built_in">module</span>.resource) &amp;&amp;</div><div class="line">          <span class="built_in">module</span>.resource.indexOf(</div><div class="line">            path.join(__dirname, <span class="string">'../node_modules'</span>)</div><div class="line">          ) === <span class="number">0</span></div><div class="line">        )</div><div class="line">      &#125;</div><div class="line">    &#125;),</div><div class="line">    <span class="comment">// extract webpack runtime and module manifest to its own file in order to</span></div><div class="line">    <span class="comment">// prevent vendor hash from being updated whenever app bundle is updated</span></div><div class="line">    <span class="comment">// 声明两次CommonsChunkPlugin是为了避免bundle更新时，vendor的hash改变</span></div><div class="line">    <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</div><div class="line">    	<span class="comment">// 长期缓存webpack静态资源的方案</span></div><div class="line">    	<span class="comment">// 生成含有chunk信息的manifest文件，包括chunk hash和chunk 目录</span></div><div class="line">      name: <span class="string">'manifest'</span>,</div><div class="line">      <span class="comment">// 定位chunk</span></div><div class="line">      chunks: [<span class="string">'vendor'</span>]</div><div class="line">    &#125;),</div><div class="line"></div><div class="line">    <span class="comment">// copy custom static assets</span></div><div class="line">    <span class="comment">// 复制静态资源地址</span></div><div class="line">    <span class="keyword">new</span> CopyWebpackPlugin([</div><div class="line">      &#123;</div><div class="line">        <span class="attr">from</span>: path.resolve(__dirname, <span class="string">'../static'</span>),</div><div class="line">        <span class="attr">to</span>: config.build.assetsSubDirectory,</div><div class="line">        <span class="attr">ignore</span>: [<span class="string">'.*'</span>]</div><div class="line">      &#125;</div><div class="line">    ])</div><div class="line">  ]</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="keyword">if</span> (config.build.productionGzip) &#123;</div><div class="line">  <span class="comment">// 在生产环境下，启动压缩代码插件</span></div><div class="line">  <span class="keyword">var</span> CompressionWebpackPlugin = <span class="built_in">require</span>(<span class="string">'compression-webpack-plugin'</span>)</div><div class="line"></div><div class="line">  webpackConfig.plugins.push(</div><div class="line">    <span class="comment">// 配置压缩代码插件</span></div><div class="line">    <span class="keyword">new</span> CompressionWebpackPlugin(&#123;</div><div class="line">      <span class="comment">// 目标资源名称</span></div><div class="line">      asset: <span class="string">'[path].gz[query]'</span>,</div><div class="line">      <span class="comment">// 压缩算法</span></div><div class="line">      algorithm: <span class="string">'gzip'</span>,</div><div class="line">      <span class="comment">//  所有匹配该正则的资源都会被处理</span></div><div class="line">      test: <span class="keyword">new</span> <span class="built_in">RegExp</span>(</div><div class="line">        <span class="string">'\\.('</span> +</div><div class="line">        config.build.productionGzipExtensions.join(<span class="string">'|'</span>) +</div><div class="line">        <span class="string">')$'</span></div><div class="line">      ),</div><div class="line">      <span class="attr">threshold</span>: <span class="number">10240</span>,</div><div class="line">      <span class="comment">//  只有压缩率小于这个值的资源才会被处理</span></div><div class="line">      minRatio: <span class="number">0.8</span></div><div class="line">    &#125;)</div><div class="line">  )</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="流程原理"><a href="#流程原理" class="headerlink" title="流程原理"></a>流程原理</h3><h4 id="简略版"><a href="#简略版" class="headerlink" title="简略版"></a>简略版</h4><p><img src="http://upload-images.jianshu.io/upload_images/1945738-f1379447d7a0417c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="简要图示"><br>webpack根据模块的依赖关系进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源。</p>
<h4 id="详细版"><a href="#详细版" class="headerlink" title="详细版"></a>详细版</h4><ol>
<li>所有代码和文件经由<code>loader</code>转换器，处理成模块</li>
<li>webpack分析入口文件（<code>entry.js</code>）,解析模块间依赖关系，构建依赖关系图（<code>dependency graph</code>）</li>
<li>webpack凭借依赖关系进行代码分离（<code>code spliting</code>）和整理</li>
<li>webpack进行模块打包，生成对应的静态资源</li>
</ol>
<h4 id="细节版"><a href="#细节版" class="headerlink" title="细节版"></a>细节版</h4><ol>
<li>命令行输入webpack,系统调用<code>./node_modules/.bin/webpack</code>这个脚本（shell），这个脚本调用<code>./node_modules/webpack/bin/webpack.js</code>并追加输入的参数，如<code>-p</code>(混淆压缩代码)、<code>-w</code>(监控自动打包)</li>
<li>webpack通过<code>optimist</code>（一个<code>node.js</code>库，用来解析选项）将用户配置的<code>webpack.config.js</code>和<code>shell</code>脚本传来的参数整合成<code>option对象</code>传入下一个流程中</li>
<li>webpack初始化，构建<code>complilation</code>对象，该对象负责组织整个编译过程，包含了每个构建环节所对应的方法</li>
<li>找到入口文件，解析入口文件，通过对应的工厂方法创建模块，保存到<code>compilation</code>对象上</li>
<li>创建依赖关系图，对依赖链上的模块依次（异步）进行build操作，调用loader处理源文件</li>
<li>调用<code>seal</code>方法封装，生成编译后的代码，每一个chunk对应一个入口文件，逐次对每个chunk整理、合并、拆分</li>
<li>处理生成最后的文件</li>
<li>有一个实现插件绑定与调用的库（<code>tapable</code>），贯穿整个webpack打包编译过程，不同的插件通过自身的<code>apply</code>方法调用<code>tapable</code>的<code>plugin</code>方法，将插件添加对<code>compiler</code>对象，从而在编译的不同时期对文件进行相应的处理。</li>
</ol>
<p>参考图示：<br><img src="https://img.alicdn.com/tps/TB1GVGFNXXXXXaTapXXXXXXXXXX-4436-4244.jpg" alt="webpack工作流程-来自TB前端团队"></p>
<h4 id="从Complier的事件钩子看编译流程"><a href="#从Complier的事件钩子看编译流程" class="headerlink" title="从Complier的事件钩子看编译流程"></a>从<code>Complier</code>的事件钩子看编译流程</h4><blockquote>
<p>webpack 的 <code>Compiler</code>模块是创建一个传入<code>webpack CLI</code>、 <code>webpack api</code> 或 webpack 配置文件等选项的编译实例的主引擎。</p>
</blockquote>
<p>这是 Compiler 暴露的所有事件钩子的参考指南</p>
<table>
<thead>
<tr>
<th>事件名称</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>entry-options</td>
<td>-</td>
</tr>
<tr>
<td>after-plugins</td>
<td>设置插件的初始配置后</td>
</tr>
<tr>
<td>after-resolvers</td>
<td>设置解析器后</td>
</tr>
<tr>
<td>environment</td>
<td>-</td>
</tr>
<tr>
<td>after-environment</td>
<td>环境配置完成</td>
</tr>
<tr>
<td>before-run</td>
<td>compiler.run() 开始</td>
</tr>
<tr>
<td>run</td>
<td>读取记录之前</td>
</tr>
<tr>
<td>watch-run</td>
<td>监视后开始编译之前</td>
</tr>
<tr>
<td>normal-module-factory</td>
<td>创建 NormalModuleFactory 后</td>
</tr>
<tr>
<td>context-module-factory</td>
<td>创建 ContextModuleFactory 后</td>
</tr>
<tr>
<td>before-compile</td>
<td>编译参数创建完成</td>
</tr>
<tr>
<td>compile</td>
<td>创建新编译之前</td>
</tr>
<tr>
<td>this-compilation</td>
<td>发送 compilation 事件之前</td>
</tr>
<tr>
<td>compilation</td>
<td>编译创建完成</td>
</tr>
<tr>
<td>make</td>
<td>-</td>
</tr>
<tr>
<td>after-compile</td>
<td>-</td>
</tr>
<tr>
<td>should-emit</td>
<td>此时可以返回 true/false</td>
</tr>
<tr>
<td>need-additional-pass</td>
<td>-</td>
</tr>
<tr>
<td>emit</td>
<td>在发送资源到输出目录之前</td>
</tr>
<tr>
<td>after-emit</td>
<td>在发送资源到输出目录之后</td>
</tr>
<tr>
<td>done</td>
<td>完成编译</td>
</tr>
<tr>
<td>failed</td>
<td>编译失败</td>
</tr>
<tr>
<td>invalid</td>
<td>一个监控的编译变无效后</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h3><h4 id="代码分离"><a href="#代码分离" class="headerlink" title="代码分离"></a>代码分离</h4><blockquote>
<p>代码分离是 webpack 中最引人注目的特性之一。此特性能够把代码分离到不同的 bundle 中，然后可以按需加载或并行加载这些文件。代码分离可以用于获取更小的 bundle，以及控制资源加载优先级，如果使用合理，会极大影响加载时间。</p>
</blockquote>
<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><h5 id="入口起点"><a href="#入口起点" class="headerlink" title="入口起点"></a>入口起点</h5><p>使用 entry 选项手动分离代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">entry: &#123;</div><div class="line">  index: &apos;./src/index.js&apos;,</div><div class="line">  another: &apos;./src/another-module.js&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样的方案需要开发者在开发过程中就对模块的组织有清晰的规划，整理出入口文件。</p>
<h5 id="防止重复"><a href="#防止重复" class="headerlink" title="防止重复"></a>防止重复</h5><p>使用 CommonsChunkPlugin 去重和分离 chunk。</p>
<blockquote>
<p>CommonsChunkPlugin 插件，是一个可选的用于建立一个独立文件(又称作 chunk)的功能，这个文件包括多个入口 chunk 的公共模块。通过将公共模块拆出来，最终合成的文件能够在最开始的时候加载一次，便存起来到缓存中供后续使用。这个带来速度上的提升，因为浏览器会迅速将公共的代码从缓存中取出来，而不是每次访问一个新页面时，再去加载一个更大的文件。</p>
</blockquote>
<h5 id="动态导入"><a href="#动态导入" class="headerlink" title="动态导入"></a>动态导入</h5><p>通过模块的内联函数调用来分离代码</p>
<p>如<code>require.ensure()</code>动态导入模块，output会生成额外的chunkFile</p>
<h4 id="Webpack-Dev-Server介绍"><a href="#Webpack-Dev-Server介绍" class="headerlink" title="Webpack Dev Server介绍"></a>Webpack Dev Server介绍</h4><p><code>webpack dev server</code>是webpack提供的本地开发服务器，内建有<code>liveReload</code>功能。</p>
<h5 id="概念了解"><a href="#概念了解" class="headerlink" title="概念了解"></a>概念了解</h5><table>
<thead>
<tr>
<th></th>
<th>代码同步对象</th>
<th>webpack</th>
<th>浏览器刷新</th>
<th>是否需要服务器</th>
</tr>
</thead>
<tbody>
<tr>
<td>watch mode</td>
<td>webpack</td>
<td>自动打包</td>
<td>手动刷新</td>
<td>否</td>
</tr>
<tr>
<td>liveReload</td>
<td>浏览器视图</td>
<td>自动打包</td>
<td>自动刷新全部</td>
<td>是</td>
</tr>
<tr>
<td>hotReload</td>
<td>浏览器视图中对应部分</td>
<td>自动打包</td>
<td>自动刷新修改部分</td>
<td>是</td>
</tr>
</tbody>
</table>
<p><code>webpack dev server</code>基于<code>Express</code>，使用<code>webpack-dev-middleware</code>来支持webpack的打包,它使用内存编译，这意味着bundle不会被保存在硬盘上</p>
<h5 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h5><ul>
<li>安装：<code>npm install --save-dev webpack-dev-server</code></li>
<li>唤起：<code>webpack-dev-server --open</code></li>
</ul>
<p>或者在package.json中配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&quot;scripts&quot;: &#123;</div><div class="line">    &quot;start&quot;: &quot;webpack-dev-server&quot;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>使用<code>npm start</code>打开服务器，即可在<code>http://localhost:8080</code>中查看</p>
<p>关于Wepack Dev Server的<a href="https://doc.webpack-china.org/configuration/dev-server/" target="_blank" rel="external">详细配置</a></p>
<p><br><br><br></p>
<h4 id="HMR（Hot-Module-Replacement）介绍"><a href="#HMR（Hot-Module-Replacement）介绍" class="headerlink" title="HMR（Hot-Module-Replacement）介绍"></a>HMR（Hot-Module-Replacement）介绍</h4><p>模块热替换HMR功能会在应用程序运行过程中替换、添加或删除模块，而无需重新加载整个页面。主要是通过以下几种方式，来显著加快开发速度：</p>
<ul>
<li>保留应用程序状态</li>
<li>只更新变更内容</li>
<li>调整样式更快</li>
</ul>
<h5 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h5><ol>
<li><p>应用程序要求HMR检查更新（<code>check</code>方法）</p>
</li>
<li><p>HMR找到修改模块，下载更新，更新由两部分组成：</p>
<ul>
<li>一个或多个更新后的chunk补丁文件（<code>.js</code>）：每个chunk都含有对应于此chunk的全部更新模块的代码。</li>
<li>描述性文件<code>manifest</code>（<code>.json</code>）：包括新的编译 hash 和所有的待更新 chunk 目录</li>
</ul>
</li>
<li><p>应用程序代码要求HMR应用更新（<code>apply</code>方法）</p>
</li>
<li><p>HMR应用更新。启用<code>webpack-dev-server</code>服务时，server会响应客户端发起的<code>eventStream</code>请求，保持请求不断，服务器就可以把结果push到浏览器</p>
</li>
</ol>
<h5 id="使用方式（使用webpack-dev-server服务）"><a href="#使用方式（使用webpack-dev-server服务）" class="headerlink" title="使用方式（使用webpack-dev-server服务）"></a>使用方式（使用<code>webpack-dev-server</code>服务）</h5><p>通过在<code>webpack.config.js</code>或<code>webpack.dev.conf.js</code>中进行配置插件使用<br><code>HotModuleReplacementPlugin</code>插件挂载在webpack下，所有不需要另外安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">plugins: [</div><div class="line">    new webpack.HotModuleReplacementPlugin() // 启用 HMR</div><div class="line">  ],</div><div class="line">devServer: &#123;</div><div class="line">    hot: true, // 告诉 dev-server 我们在使用 HMR</div><div class="line">    contentBase: path.resolve(__dirname, &apos;dist&apos;),</div><div class="line">    publicPath: &apos;/&apos;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>此时HMR的接口暴露在<code>module.hot</code>下，通过在<code>module.hot</code>下使用HMR的方法，实现在更新周期中的操作，如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if (module.hot) &#123;</div><div class="line">  module.hot.accept(&apos;./library.js&apos;, function() &#123;</div><div class="line">    // 使用更新过的 library 模块执行某些操作...</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当我们不使用任何方法时，HMR默认会进行冒泡更新，一个模块被更新时，整组依赖模块（模块树）都会重新加载</p>
<p>当我们有自己的服务器又想使用HMR功能时，可以采用<code>webpack-dev-middleware</code> + <code>webpack-hot-middleware</code>的解决方案</p>
<p>指路：<a href="https://github.com/glenjamin/webpack-hot-middleware" target="_blank" rel="external">Webpack Hot Middleware</a></p>
<p><br><br><br></p>
<h4 id="常用插件介绍"><a href="#常用插件介绍" class="headerlink" title="常用插件介绍"></a>常用插件介绍</h4><table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>CommonsChunkPlugin</td>
<td>将多个入口起点之间共享的公共模块，生成为一些 chunk，并且分离到单独的 bundle 中，例如，vendor.bundle.js 和 app.bundle.js</td>
</tr>
<tr>
<td>DefinePlugin</td>
<td>允许在编译时(compile time)配置的全局常量，用于允许「开发/发布」构建之间的不同行为</td>
</tr>
<tr>
<td>HtmlWebpackPlugin</td>
<td>用于简化 HTML 文件（index.html）的创建，提供访问 bundle 的服务</td>
</tr>
<tr>
<td>IgnorePlugin</td>
<td>从 bundle 中排除某些模块</td>
</tr>
<tr>
<td>ExtractTextPlugin</td>
<td>将所有的入口chunk中引用的 *.css，移动到独立分离的 CSS 文件。</td>
</tr>
<tr>
<td>CompressionWebpackPlugin</td>
<td>帮助压缩代码</td>
</tr>
<tr>
<td>UglifyJsPlugin</td>
<td>帮助混淆代码</td>
</tr>
</tbody>
</table>
<p>更多插件：<a href="https://doc.webpack-china.org/plugins/compression-webpack-plugin/" target="_blank" rel="external">https://doc.webpack-china.org/plugins/compression-webpack-plugin/</a><br><br><br><br></p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul>
<li><a href="https://doc.webpack-china.org/concepts/" target="_blank" rel="external">doc.webpack-china.org</a></li>
<li><a href="http://taobaofed.org/blog/2016/09/09/webpack-flow/" target="_blank" rel="external">细说 webpack 之流程篇</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h3&gt;&lt;p&gt;webpack是当下流行的前端工程打包工具，本文较深入地分析了其运作原理，以及一些常用功能的实现思路。&lt;br&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://escawn.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="webpack" scheme="https://escawn.github.io/tags/webpack/"/>
    
  </entry>
  
</feed>
